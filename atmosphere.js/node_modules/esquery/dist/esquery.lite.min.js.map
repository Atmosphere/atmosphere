{"version":3,"file":"esquery.lite.min.js","sources":["../parser.js","../esquery.js"],"sourcesContent":["/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(ss) {\n            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };\n          },\n        peg$c1 = function() { return void 0; },\n        peg$c2 = \" \",\n        peg$c3 = peg$literalExpectation(\" \", false),\n        peg$c4 = /^[^ [\\],():#!=><~+.]/,\n        peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n        peg$c6 = function(i) { return i.join(''); },\n        peg$c7 = \">\",\n        peg$c8 = peg$literalExpectation(\">\", false),\n        peg$c9 = function() { return 'child'; },\n        peg$c10 = \"~\",\n        peg$c11 = peg$literalExpectation(\"~\", false),\n        peg$c12 = function() { return 'sibling'; },\n        peg$c13 = \"+\",\n        peg$c14 = peg$literalExpectation(\"+\", false),\n        peg$c15 = function() { return 'adjacent'; },\n        peg$c16 = function() { return 'descendant'; },\n        peg$c17 = \",\",\n        peg$c18 = peg$literalExpectation(\",\", false),\n        peg$c19 = function(s, ss) {\n          return [s].concat(ss.map(function (s) { return s[3]; }));\n        },\n        peg$c20 = function(op, s) {\n            if (!op) return s;\n            return { type: op, left: { type: 'exactNode' }, right: s };\n          },\n        peg$c21 = function(a, ops) {\n            return ops.reduce(function (memo, rhs) {\n              return { type: rhs[0], left: memo, right: rhs[1] };\n            }, a);\n          },\n        peg$c22 = \"!\",\n        peg$c23 = peg$literalExpectation(\"!\", false),\n        peg$c24 = function(subject, as) {\n            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };\n            if(subject) b.subject = true;\n            return b;\n          },\n        peg$c25 = \"*\",\n        peg$c26 = peg$literalExpectation(\"*\", false),\n        peg$c27 = function(a) { return { type: 'wildcard', value: a }; },\n        peg$c28 = \"#\",\n        peg$c29 = peg$literalExpectation(\"#\", false),\n        peg$c30 = function(i) { return { type: 'identifier', value: i }; },\n        peg$c31 = \"[\",\n        peg$c32 = peg$literalExpectation(\"[\", false),\n        peg$c33 = \"]\",\n        peg$c34 = peg$literalExpectation(\"]\", false),\n        peg$c35 = function(v) { return v; },\n        peg$c36 = /^[><!]/,\n        peg$c37 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n        peg$c38 = \"=\",\n        peg$c39 = peg$literalExpectation(\"=\", false),\n        peg$c40 = function(a) { return (a || '') + '='; },\n        peg$c41 = /^[><]/,\n        peg$c42 = peg$classExpectation([\">\", \"<\"], false, false),\n        peg$c43 = \".\",\n        peg$c44 = peg$literalExpectation(\".\", false),\n        peg$c45 = function(a, as) {\n            return [].concat.apply([a], as).join('');\n          },\n        peg$c46 = function(name, op, value) {\n              return { type: 'attribute', name: name, operator: op, value: value };\n            },\n        peg$c47 = function(name) { return { type: 'attribute', name: name }; },\n        peg$c48 = \"\\\"\",\n        peg$c49 = peg$literalExpectation(\"\\\"\", false),\n        peg$c50 = /^[^\\\\\"]/,\n        peg$c51 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n        peg$c52 = \"\\\\\",\n        peg$c53 = peg$literalExpectation(\"\\\\\", false),\n        peg$c54 = peg$anyExpectation(),\n        peg$c55 = function(a, b) { return a + b; },\n        peg$c56 = function(d) {\n                return { type: 'literal', value: strUnescape(d.join('')) };\n              },\n        peg$c57 = \"'\",\n        peg$c58 = peg$literalExpectation(\"'\", false),\n        peg$c59 = /^[^\\\\']/,\n        peg$c60 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n        peg$c61 = /^[0-9]/,\n        peg$c62 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c63 = function(a, b) {\n                // Can use `a.flat().join('')` once supported\n                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n                return { type: 'literal', value: parseFloat(leadingDecimals + b.join('')) };\n              },\n        peg$c64 = function(i) { return { type: 'literal', value: i }; },\n        peg$c65 = \"type(\",\n        peg$c66 = peg$literalExpectation(\"type(\", false),\n        peg$c67 = /^[^ )]/,\n        peg$c68 = peg$classExpectation([\" \", \")\"], true, false),\n        peg$c69 = \")\",\n        peg$c70 = peg$literalExpectation(\")\", false),\n        peg$c71 = function(t) { return { type: 'type', value: t.join('') }; },\n        peg$c72 = /^[imsu]/,\n        peg$c73 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n        peg$c74 = \"/\",\n        peg$c75 = peg$literalExpectation(\"/\", false),\n        peg$c76 = function(pattern, flgs) {\n              return {\n                type: 'regexp', value: new RegExp(pattern.join(''), flgs ? flgs.join('') : '')\n              };\n            },\n        peg$c77 = /^[^\\]\\\\]/,\n        peg$c78 = peg$classExpectation([\"]\", \"\\\\\"], true, false),\n        peg$c79 = function(cs) { return '[' + cs.join('') + ']'; },\n        peg$c80 = function(a) { return '\\\\' + a; },\n        peg$c81 = /^[^\\/\\\\[]/,\n        peg$c82 = peg$classExpectation([\"/\", \"\\\\\", \"[\"], true, false),\n        peg$c83 = function(cs) { return cs.join(''); },\n        peg$c84 = function(i, is) {\n          return { type: 'field', name: is.reduce(function(memo, p){ return memo + p[0] + p[1]; }, i)};\n        },\n        peg$c85 = \":not(\",\n        peg$c86 = peg$literalExpectation(\":not(\", false),\n        peg$c87 = function(ss) { return { type: 'not', selectors: ss }; },\n        peg$c88 = \":matches(\",\n        peg$c89 = peg$literalExpectation(\":matches(\", false),\n        peg$c90 = function(ss) { return { type: 'matches', selectors: ss }; },\n        peg$c91 = \":is(\",\n        peg$c92 = peg$literalExpectation(\":is(\", false),\n        peg$c93 = \":has(\",\n        peg$c94 = peg$literalExpectation(\":has(\", false),\n        peg$c95 = function(ss) { return { type: 'has', selectors: ss }; },\n        peg$c96 = \":first-child\",\n        peg$c97 = peg$literalExpectation(\":first-child\", false),\n        peg$c98 = function() { return nth(1); },\n        peg$c99 = \":last-child\",\n        peg$c100 = peg$literalExpectation(\":last-child\", false),\n        peg$c101 = function() { return nthLast(1); },\n        peg$c102 = \":nth-child(\",\n        peg$c103 = peg$literalExpectation(\":nth-child(\", false),\n        peg$c104 = function(n) { return nth(parseInt(n.join(''), 10)); },\n        peg$c105 = \":nth-last-child(\",\n        peg$c106 = peg$literalExpectation(\":nth-last-child(\", false),\n        peg$c107 = function(n) { return nthLast(parseInt(n.join(''), 10)); },\n        peg$c108 = \":\",\n        peg$c109 = peg$literalExpectation(\":\", false),\n        peg$c110 = function(c) {\n          return { type: 'class', name: c };\n        },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselectors();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifierName() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c4.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebinaryOp() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c7;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c9();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 126) {\n            s2 = peg$c10;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c11); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s2 = peg$c13;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c15();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c16();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehasSelectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 36 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsehasSelector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehasSelector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsehasSelector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 36 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseselector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseselector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseselector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehasSelector() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsebinaryOp();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselector();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselector() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequence();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsebinaryOp();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesequence();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsebinaryOp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesequence();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c21(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequence() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseatom();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseatom();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c24(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseatom() {\n      var s0;\n\n      var key    = peg$currPos * 36 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsewildcard();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseattr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefield();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsenegation();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsematches();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseis();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsehas();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsefirstChild();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parselastChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenthChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthLastChild();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parseclass();\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewildcard() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s1 = peg$c25;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c27(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c30(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattr() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrValue();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c33;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c34); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c35(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c36.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c38;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c40(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (peg$c41.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrEqOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c38;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c40(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c43;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c44); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseidentifierName();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c43;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c44); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidentifierName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c45(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrValue() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseattrName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrEqOps();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetype();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseregex();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c46(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseattrName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrOps();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsestring();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parsepath();\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c46(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c47(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c48;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s4 = peg$c52;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c53); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c54); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c55(s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c52;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c54); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c55(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c48;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c56(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c57;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c58); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c59.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c60); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c52;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c54); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c55(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c59.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c60); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c52;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c55(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s3 = peg$c57;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c56(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c61.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c62); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c43;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c44); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c62); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c63(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c64(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetype() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c65) {\n        s1 = peg$c65;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c66); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c67.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c68); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c67.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c68); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c71(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseflags() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (peg$c72.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c73); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c72.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseregex() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 36 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c74;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c75); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsere_character_class();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsere_escape();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsere_chars();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsere_character_class();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsere_escape();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parsere_chars();\n              }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s3 = peg$c74;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c75); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseflags();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c76(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsere_character_class() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c77.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c78); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsere_escape();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c77.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsere_escape();\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c33;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c79(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsere_escape() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c52;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c80(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsere_chars() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c81.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c82); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c81.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c82); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c83(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefield() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 36 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c43;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c44); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseidentifierName();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c43;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c44); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseidentifierName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c84(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenegation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c85) {\n        s1 = peg$c85;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c87(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsematches() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c88) {\n        s1 = peg$c88;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c90(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseis() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c91) {\n        s1 = peg$c91;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c92); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c90(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehas() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 30,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c93) {\n        s1 = peg$c93;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c94); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsehasSelectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c95(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefirstChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 31,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 12) === peg$c96) {\n        s1 = peg$c96;\n        peg$currPos += 12;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c97); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c98();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselastChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 32,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c99) {\n        s1 = peg$c99;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c100); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c101();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 33,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c102) {\n        s1 = peg$c102;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c103); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c61.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c62); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c61.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c62); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c104(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthLastChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 34,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 16) === peg$c105) {\n        s1 = peg$c105;\n        peg$currPos += 16;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c106); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c61.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c62); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c61.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c62); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c107(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseclass() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 35,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c108;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c109); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c110(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      function nth(n) { return { type: 'nth-child', index: { type: 'literal', value: n } }; }\n      function nthLast(n) { return { type: 'nth-last-child', index: { type: 'literal', value: n } }; }\n      function strUnescape(s) {\n        return s.replace(/\\\\(.)/g, function(match, ch) {\n          switch(ch) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            default: return ch;\n          }\n        });\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n","/* vim: set sw=4 sts=4 : */\nimport estraverse from 'estraverse';\nimport parser from './parser.js';\n\n/**\n* @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n*/\n\nconst LEFT_SIDE = 'LEFT_SIDE';\nconst RIGHT_SIDE = 'RIGHT_SIDE';\n\n/**\n * @external AST\n * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n */\n\n/**\n * One of the rules of `grammar.pegjs`\n * @typedef {PlainObject} SelectorAST\n * @see grammar.pegjs\n*/\n\n/**\n * The `sequence` production of `grammar.pegjs`\n * @typedef {PlainObject} SelectorSequenceAST\n*/\n\n/**\n * Get the value of a property which may be multiple levels down\n * in the object.\n * @param {?PlainObject} obj\n * @param {string[]} keys\n * @returns {undefined|boolean|string|number|external:AST}\n */\nfunction getPath(obj, keys) {\n    for (let i = 0; i < keys.length; ++i) {\n        if (obj == null) { return obj; }\n        obj = obj[keys[i]];\n    }\n    return obj;\n}\n\n/**\n * Determine whether `node` can be reached by following `path`,\n * starting at `ancestor`.\n * @param {?external:AST} node\n * @param {?external:AST} ancestor\n * @param {string[]} path\n * @param {Integer} fromPathIndex\n * @returns {boolean}\n */\nfunction inPath(node, ancestor, path, fromPathIndex) {\n    let current = ancestor;\n    for (let i = fromPathIndex; i < path.length; ++i) {\n        if (current == null) {\n            return false;\n        }\n        const field = current[path[i]];\n        if (Array.isArray(field)) {\n            for (let k = 0; k < field.length; ++k) {\n                if (inPath(node, field[k], path, i + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        current = field;\n    }\n    return node === current;\n}\n\n/**\n * A generated matcher function for a selector.\n * @callback SelectorMatcher\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @returns {void}\n*/\n\n/**\n * A WeakMap for holding cached matcher functions for selectors.\n * @type {WeakMap<SelectorAST, SelectorMatcher>}\n*/\nconst MATCHER_CACHE = typeof WeakMap === 'function' ? new WeakMap : null;\n\n/**\n * Look up a matcher function for `selector` in the cache.\n * If it does not exist, generate it with `generateMatcher` and add it to the cache.\n * In engines without WeakMap, the caching is skipped and matchers are generated with every call.\n * @param {?SelectorAST} selector\n * @returns {SelectorMatcher}\n */\nfunction getMatcher(selector) {\n    if (selector == null) {\n        return () => true;\n    }\n\n    if (MATCHER_CACHE != null) {\n        let matcher = MATCHER_CACHE.get(selector);\n        if (matcher != null) {\n            return matcher;\n        }\n        matcher = generateMatcher(selector);\n        MATCHER_CACHE.set(selector, matcher);\n        return matcher;\n    }\n\n    return generateMatcher(selector);\n}\n\n/**\n * Create a matcher function for `selector`,\n * @param {?SelectorAST} selector\n * @returns {SelectorMatcher}\n */\nfunction generateMatcher(selector) {\n    switch(selector.type) {\n        case 'wildcard':\n            return () => true;\n\n        case 'identifier': {\n            const value = selector.value.toLowerCase();\n            return (node, ancestry, options) => {\n                const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n                return value === node[nodeTypeKey].toLowerCase();\n            };\n        }\n\n        case 'exactNode':\n            return (node, ancestry) => {\n                return ancestry.length === 0;\n            };\n\n        case 'field': {\n            const path = selector.name.split('.');\n            return (node, ancestry) => {\n                const ancestor = ancestry[path.length - 1];\n                return inPath(node, ancestor, path, 0);\n            };\n        }\n\n        case 'matches': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                for (let i = 0; i < matchers.length; ++i) {\n                    if (matchers[i](node, ancestry, options)) { return true; }\n                }\n                return false;\n            };\n        }\n\n        case 'compound': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                for (let i = 0; i < matchers.length; ++i) {\n                    if (!matchers[i](node, ancestry, options)) { return false; }\n                }\n                return true;\n            };\n        }\n\n        case 'not': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                for (let i = 0; i < matchers.length; ++i) {\n                    if (matchers[i](node, ancestry, options)) { return false; }\n                }\n                return true;\n            };\n        }\n\n        case 'has': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                let result = false;\n\n                const a = [];\n                estraverse.traverse(node, {\n                    enter (node, parent) {\n                        if (parent != null) { a.unshift(parent); }\n\n                        for (let i = 0; i < matchers.length; ++i) {\n                            if (matchers[i](node, a, options)) {\n                                result = true;\n                                this.break();\n                                return;\n                            }\n                        }\n                    },\n                    leave () { a.shift(); },\n                    keys: options && options.visitorKeys,\n                    fallback: options && options.fallback || 'iteration'\n                });\n\n                return result;\n            };\n        }\n\n        case 'child': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) => {\n                if (ancestry.length > 0 && right(node, ancestry, options)) {\n                    return left(ancestry[0], ancestry.slice(1), options);\n                }\n                return false;\n            };\n        }\n\n        case 'descendant': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) => {\n                if (right(node, ancestry, options)) {\n                    for (let i = 0, l = ancestry.length; i < l; ++i) {\n                        if (left(ancestry[i], ancestry.slice(i + 1), options)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            };\n        }\n\n        case 'attribute': {\n            const path = selector.name.split('.');\n            switch (selector.operator) {\n                case void 0:\n                    return (node) => getPath(node, path) != null;\n                case '=':\n                    switch (selector.value.type) {\n                        case 'regexp':\n                            return (node) => {\n                                const p = getPath(node, path);\n                                return typeof p === 'string' && selector.value.value.test(p);\n                            };\n                        case 'literal': {\n                            const literal = `${selector.value.value}`;\n                            return (node) => literal === `${getPath(node, path)}`;\n                        }\n                        case 'type':\n                            return (node) => selector.value.value === typeof getPath(node, path);\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '!=':\n                    switch (selector.value.type) {\n                        case 'regexp':\n                            return (node) => !selector.value.value.test(getPath(node, path));\n                        case 'literal': {\n                            const literal = `${selector.value.value}`;\n                            return (node) => literal !== `${getPath(node, path)}`;\n                        }\n                        case 'type':\n                            return (node) => selector.value.value !== typeof getPath(node, path);\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '<=':\n                    return (node) => getPath(node, path) <= selector.value.value;\n                case '<':\n                    return (node) => getPath(node, path) < selector.value.value;\n                case '>':\n                    return (node) => getPath(node, path) > selector.value.value;\n                case '>=':\n                    return (node) => getPath(node, path) >= selector.value.value;\n            }\n            throw new Error(`Unknown operator: ${selector.operator}`);\n        }\n\n        case 'sibling': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    sibling(node, left, ancestry, LEFT_SIDE, options) ||\n                    selector.left.subject &&\n                    left(node, ancestry, options) &&\n                    sibling(node, right, ancestry, RIGHT_SIDE, options);\n        }\n\n        case 'adjacent': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    adjacent(node, left, ancestry, LEFT_SIDE, options) ||\n                    selector.right.subject &&\n                    left(node, ancestry, options) &&\n                    adjacent(node, right, ancestry, RIGHT_SIDE, options);\n        }\n\n        case 'nth-child': {\n            const nth = selector.index.value;\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    nthChild(node, ancestry, nth, options);\n        }\n\n        case 'nth-last-child': {\n            const nth = -selector.index.value;\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    nthChild(node, ancestry, nth, options);\n        }\n\n        case 'class': {\n            \n            const name = selector.name.toLowerCase();\n\n            return (node, ancestry, options) => {\n                \n                if (options && options.matchClass) {\n                    return options.matchClass(selector.name, node, ancestry);\n                }\n                \n                if (options && options.nodeTypeKey) return false;    \n\n                switch(name){\n                    case 'statement':\n                        if(node.type.slice(-9) === 'Statement') return true;\n                        // fallthrough: interface Declaration <: Statement { }\n                    case 'declaration':\n                        return node.type.slice(-11) === 'Declaration';\n                    case 'pattern':\n                        if(node.type.slice(-7) === 'Pattern') return true;\n                        // fallthrough: interface Expression <: Node, Pattern { }\n                    case 'expression':\n                        return node.type.slice(-10) === 'Expression' ||\n                            node.type.slice(-7) === 'Literal' ||\n                            (\n                                node.type === 'Identifier' &&\n                                (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\n                            ) ||\n                            node.type === 'MetaProperty';\n                    case 'function':\n                        return node.type === 'FunctionDeclaration' ||\n                            node.type === 'FunctionExpression' ||\n                            node.type === 'ArrowFunctionExpression';\n                }\n                throw new Error(`Unknown class name: ${selector.name}`);\n            };\n        }\n    }\n\n    throw new Error(`Unknown selector type: ${selector.type}`);\n}\n\n/**\n * @callback TraverseOptionFallback\n * @param {external:AST} node The given node.\n * @returns {string[]} An array of visitor keys for the given node.\n */\n\n/**\n * @callback ClassMatcher\n * @param {string} className The name of the class to match.\n * @param {external:AST} node The node to match against.\n * @param {Array<external:AST>} ancestry The ancestry of the node.\n * @returns {boolean} True if the node matches the class, false if not.\n */\n\n/**\n * @typedef {object} ESQueryOptions\n * @property {string} [nodeTypeKey=\"type\"] By passing `nodeTypeKey`, we can allow other ASTs to use ESQuery.\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n * @property {ClassMatcher} [matchClass] By passing `matchClass` option, we can customize the interpretation of classes.\n */\n\n/**\n * Given a `node` and its ancestors, determine if `node` is matched\n * by `selector`.\n * @param {?external:AST} node\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @throws {Error} Unknowns (operator, class name, selector type, or\n * selector value type)\n * @returns {boolean}\n */\nfunction matches(node, selector, ancestry, options) {\n    if (!selector) { return true; }\n    if (!node) { return false; }\n    if (!ancestry) { ancestry = []; }\n\n    return getMatcher(selector)(node, ancestry, options);\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {external:AST} node The AST node to get keys.\n * @param {ESQueryOptions|undefined} options\n * @returns {string[]} Visitor keys of the node.\n */\nfunction getVisitorKeys(node, options) {\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n\n    const nodeType = node[nodeTypeKey];\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n        return options.visitorKeys[nodeType];\n    }\n    if (estraverse.VisitorKeys[nodeType]) {\n        return estraverse.VisitorKeys[nodeType];\n    }\n    if (options && typeof options.fallback === 'function') {\n        return options.fallback(node);\n    }\n    // 'iteration' fallback\n    return Object.keys(node).filter(function (key) {\n        return key !== nodeTypeKey;\n    });\n}\n\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} node The value to check.\n * @param {ESQueryOptions|undefined} options The options to use.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(node, options) {\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n    return node !== null && typeof node === 'object' && typeof node[nodeTypeKey] === 'string';\n}\n\n/**\n * Determines if the given node has a sibling that matches the\n * given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction sibling(node, matcher, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)) {\n            const startIndex = listProp.indexOf(node);\n            if (startIndex < 0) { continue; }\n            let lowerBound, upperBound;\n            if (side === LEFT_SIDE) {\n                lowerBound = 0;\n                upperBound = startIndex;\n            } else {\n                lowerBound = startIndex + 1;\n                upperBound = listProp.length;\n            }\n            for (let k = lowerBound; k < upperBound; ++k) {\n                if (isNode(listProp[k], options) && matcher(listProp[k], ancestry, options)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node has an adjacent sibling that matches\n * the given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction adjacent(node, matcher, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx < 0) { continue; }\n            if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1], options) && matcher(listProp[idx - 1], ancestry, options)) {\n                return true;\n            }\n            if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1], options) &&  matcher(listProp[idx + 1], ancestry, options)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node is the `nth` child.\n * If `nth` is negative then the position is counted\n * from the end of the list of children.\n * @param {external:AST} node\n * @param {external:AST[]} ancestry\n * @param {Integer} nth\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction nthChild(node, ancestry, nth, options) {\n    if (nth === 0) { return false; }\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)){\n            const idx = nth < 0 ? listProp.length + nth : nth - 1;\n            if (idx >= 0 && idx < listProp.length && listProp[idx] === node) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * For each selector node marked as a subject, find the portion of the\n * selector that the subject must match.\n * @param {SelectorAST} selector\n * @param {SelectorAST} [ancestor] Defaults to `selector`\n * @returns {SelectorAST[]}\n */\nfunction subjects(selector, ancestor) {\n    if (selector == null || typeof selector != 'object') { return []; }\n    if (ancestor == null) { ancestor = selector; }\n    const results = selector.subject ? [ancestor] : [];\n    const keys = Object.keys(selector);\n    for (let i = 0; i < keys.length; ++i) {\n        const p = keys[i];\n        const sel = selector[p];\n        results.push(...subjects(sel, p === 'left' ? sel : ancestor));\n    }\n    return results;\n}\n\n/**\n* @callback TraverseVisitor\n* @param {?external:AST} node\n* @param {?external:AST} parent\n* @param {external:AST[]} ancestry\n*/\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {TraverseVisitor} visitor\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction traverse(ast, selector, visitor, options) {\n    if (!selector) { return; }\n    const ancestry = [];\n    const matcher = getMatcher(selector);\n    const altSubjects = subjects(selector).map(getMatcher);\n    estraverse.traverse(ast, {\n        enter (node, parent) {\n            if (parent != null) { ancestry.unshift(parent); }\n            if (matcher(node, ancestry, options)) {\n                if (altSubjects.length) {\n                    for (let i = 0, l = altSubjects.length; i < l; ++i) {\n                        if (altSubjects[i](node, ancestry, options)) {\n                            visitor(node, parent, ancestry);\n                        }\n                        for (let k = 0, m = ancestry.length; k < m; ++k) {\n                            const succeedingAncestry = ancestry.slice(k + 1);\n                            if (altSubjects[i](ancestry[k], succeedingAncestry, options)) {\n                                visitor(ancestry[k], parent, succeedingAncestry);\n                            }\n                        }\n                    }\n                } else {\n                    visitor(node, parent, ancestry);\n                }\n            }\n        },\n        leave () { ancestry.shift(); },\n        keys: options && options.visitorKeys,\n        fallback: options && options.fallback || 'iteration'\n    });\n}\n\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction match(ast, selector, options) {\n    const results = [];\n    traverse(ast, selector, function (node) {\n        results.push(node);\n    }, options);\n    return results;\n}\n\n/**\n * Parse a selector string and return its AST.\n * @param {string} selector\n * @returns {SelectorAST}\n */\nfunction parse(selector) {\n    return parser.parse(selector);\n}\n\n/**\n * Query the code AST using the selector string.\n * @param {external:AST} ast\n * @param {string} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n}\n\nquery.parse = parse;\nquery.match = match;\nquery.traverse = traverse;\nquery.matches = matches;\nquery.query = query;\n\nexport default query;\n"],"names":["module","exports","peg$SyntaxError","message","expected","found","location","this","name","Error","captureStackTrace","child","parent","ctor","constructor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","i","escapedParts","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","j","descriptions","type","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c8","peg$c11","peg$c14","peg$c18","peg$c19","ss","concat","map","peg$c23","peg$c26","peg$c29","peg$c32","peg$c34","peg$c36","peg$c37","peg$c39","peg$c40","a","peg$c41","peg$c42","peg$c44","peg$c46","op","value","operator","peg$c49","peg$c50","peg$c51","peg$c53","peg$c54","peg$c55","b","peg$c56","d","match","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c66","peg$c67","peg$c68","peg$c70","peg$c72","peg$c73","peg$c75","peg$c77","peg$c78","peg$c81","peg$c82","peg$c86","peg$c89","peg$c90","selectors","peg$c92","peg$c94","peg$c97","peg$c100","peg$c103","peg$c106","peg$c109","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$resultsCache","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","push","s0","s1","s2","key","cached","nextPos","result","peg$parse_","peg$parseselectors","peg$c1","peg$parseidentifierName","test","charAt","peg$parsebinaryOp","s3","s4","s5","s6","s7","peg$parseselector","peg$parsehasSelector","left","right","peg$parsesequence","reduce","memo","rhs","subject","as","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattrName","peg$parseattrEqOps","substr","peg$parsetype","flgs","peg$parsere_character_class","peg$parsere_escape","peg$parsere_chars","peg$parseflags","RegExp","peg$parseregex","peg$parseattrOps","peg$parsestring","leadingDecimals","apply","parseFloat","peg$parsenumber","peg$parsepath","peg$parseattrValue","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parseis","peg$parsehasSelectors","peg$parsehas","nth","peg$parsefirstChild","nthLast","peg$parselastChild","parseInt","peg$parsenthChild","peg$parsenthLastChild","peg$parseclass","n","index","factory","getPath","obj","keys","MATCHER_CACHE","WeakMap","getMatcher","selector","matcher","get","generateMatcher","set","toLowerCase","node","ancestry","nodeTypeKey","path","split","inPath","ancestor","fromPathIndex","current","field","isArray","k","matchers","estraverse","traverse","enter","unshift","leave","shift","visitorKeys","fallback","l","_typeof","sibling","adjacent","nthChild","matchClass","getVisitorKeys","nodeType","VisitorKeys","Object","filter","isNode","side","_slicedToArray","listProp","startIndex","indexOf","lowerBound","upperBound","idx","ast","visitor","altSubjects","subjects","results","sel","_toConsumableArray","m","succeedingAncestry","parser","query","matches"],"mappings":"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"}