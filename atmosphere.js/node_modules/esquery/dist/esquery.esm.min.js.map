{"version":3,"file":"esquery.esm.min.js","sources":["../node_modules/estraverse/estraverse.js","../parser.js","../esquery.js"],"sourcesContent":["/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        VisitorOption,\n        VisitorKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ChainExpression: 'ChainExpression',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        PrivateIdentifier: 'PrivateIdentifier',\n        Program: 'Program',\n        Property: 'Property',\n        PropertyDefinition: 'PropertyDefinition',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ChainExpression: ['expression'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        PrivateIdentifier: [],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        PropertyDefinition: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n            this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n  \n    function candidateExistsInLeaveList(leavelist, candidate) {\n        for (var i = leavelist.length - 1; i >= 0; --i) {\n            if (leavelist[i].node === candidate) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n\n                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                              continue;\n                            }\n\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        if (candidateExistsInLeaveList(leavelist, candidate)) {\n                          continue;\n                        }\n\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(ss) {\n            return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };\n          },\n        peg$c1 = function() { return void 0; },\n        peg$c2 = \" \",\n        peg$c3 = peg$literalExpectation(\" \", false),\n        peg$c4 = /^[^ [\\],():#!=><~+.]/,\n        peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n        peg$c6 = function(i) { return i.join(''); },\n        peg$c7 = \">\",\n        peg$c8 = peg$literalExpectation(\">\", false),\n        peg$c9 = function() { return 'child'; },\n        peg$c10 = \"~\",\n        peg$c11 = peg$literalExpectation(\"~\", false),\n        peg$c12 = function() { return 'sibling'; },\n        peg$c13 = \"+\",\n        peg$c14 = peg$literalExpectation(\"+\", false),\n        peg$c15 = function() { return 'adjacent'; },\n        peg$c16 = function() { return 'descendant'; },\n        peg$c17 = \",\",\n        peg$c18 = peg$literalExpectation(\",\", false),\n        peg$c19 = function(s, ss) {\n          return [s].concat(ss.map(function (s) { return s[3]; }));\n        },\n        peg$c20 = function(op, s) {\n            if (!op) return s;\n            return { type: op, left: { type: 'exactNode' }, right: s };\n          },\n        peg$c21 = function(a, ops) {\n            return ops.reduce(function (memo, rhs) {\n              return { type: rhs[0], left: memo, right: rhs[1] };\n            }, a);\n          },\n        peg$c22 = \"!\",\n        peg$c23 = peg$literalExpectation(\"!\", false),\n        peg$c24 = function(subject, as) {\n            const b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };\n            if(subject) b.subject = true;\n            return b;\n          },\n        peg$c25 = \"*\",\n        peg$c26 = peg$literalExpectation(\"*\", false),\n        peg$c27 = function(a) { return { type: 'wildcard', value: a }; },\n        peg$c28 = \"#\",\n        peg$c29 = peg$literalExpectation(\"#\", false),\n        peg$c30 = function(i) { return { type: 'identifier', value: i }; },\n        peg$c31 = \"[\",\n        peg$c32 = peg$literalExpectation(\"[\", false),\n        peg$c33 = \"]\",\n        peg$c34 = peg$literalExpectation(\"]\", false),\n        peg$c35 = function(v) { return v; },\n        peg$c36 = /^[><!]/,\n        peg$c37 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n        peg$c38 = \"=\",\n        peg$c39 = peg$literalExpectation(\"=\", false),\n        peg$c40 = function(a) { return (a || '') + '='; },\n        peg$c41 = /^[><]/,\n        peg$c42 = peg$classExpectation([\">\", \"<\"], false, false),\n        peg$c43 = \".\",\n        peg$c44 = peg$literalExpectation(\".\", false),\n        peg$c45 = function(a, as) {\n            return [].concat.apply([a], as).join('');\n          },\n        peg$c46 = function(name, op, value) {\n              return { type: 'attribute', name: name, operator: op, value: value };\n            },\n        peg$c47 = function(name) { return { type: 'attribute', name: name }; },\n        peg$c48 = \"\\\"\",\n        peg$c49 = peg$literalExpectation(\"\\\"\", false),\n        peg$c50 = /^[^\\\\\"]/,\n        peg$c51 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n        peg$c52 = \"\\\\\",\n        peg$c53 = peg$literalExpectation(\"\\\\\", false),\n        peg$c54 = peg$anyExpectation(),\n        peg$c55 = function(a, b) { return a + b; },\n        peg$c56 = function(d) {\n                return { type: 'literal', value: strUnescape(d.join('')) };\n              },\n        peg$c57 = \"'\",\n        peg$c58 = peg$literalExpectation(\"'\", false),\n        peg$c59 = /^[^\\\\']/,\n        peg$c60 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n        peg$c61 = /^[0-9]/,\n        peg$c62 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c63 = function(a, b) {\n                // Can use `a.flat().join('')` once supported\n                const leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n                return { type: 'literal', value: parseFloat(leadingDecimals + b.join('')) };\n              },\n        peg$c64 = function(i) { return { type: 'literal', value: i }; },\n        peg$c65 = \"type(\",\n        peg$c66 = peg$literalExpectation(\"type(\", false),\n        peg$c67 = /^[^ )]/,\n        peg$c68 = peg$classExpectation([\" \", \")\"], true, false),\n        peg$c69 = \")\",\n        peg$c70 = peg$literalExpectation(\")\", false),\n        peg$c71 = function(t) { return { type: 'type', value: t.join('') }; },\n        peg$c72 = /^[imsu]/,\n        peg$c73 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n        peg$c74 = \"/\",\n        peg$c75 = peg$literalExpectation(\"/\", false),\n        peg$c76 = function(pattern, flgs) {\n              return {\n                type: 'regexp', value: new RegExp(pattern.join(''), flgs ? flgs.join('') : '')\n              };\n            },\n        peg$c77 = /^[^\\]\\\\]/,\n        peg$c78 = peg$classExpectation([\"]\", \"\\\\\"], true, false),\n        peg$c79 = function(cs) { return '[' + cs.join('') + ']'; },\n        peg$c80 = function(a) { return '\\\\' + a; },\n        peg$c81 = /^[^\\/\\\\[]/,\n        peg$c82 = peg$classExpectation([\"/\", \"\\\\\", \"[\"], true, false),\n        peg$c83 = function(cs) { return cs.join(''); },\n        peg$c84 = function(i, is) {\n          return { type: 'field', name: is.reduce(function(memo, p){ return memo + p[0] + p[1]; }, i)};\n        },\n        peg$c85 = \":not(\",\n        peg$c86 = peg$literalExpectation(\":not(\", false),\n        peg$c87 = function(ss) { return { type: 'not', selectors: ss }; },\n        peg$c88 = \":matches(\",\n        peg$c89 = peg$literalExpectation(\":matches(\", false),\n        peg$c90 = function(ss) { return { type: 'matches', selectors: ss }; },\n        peg$c91 = \":is(\",\n        peg$c92 = peg$literalExpectation(\":is(\", false),\n        peg$c93 = \":has(\",\n        peg$c94 = peg$literalExpectation(\":has(\", false),\n        peg$c95 = function(ss) { return { type: 'has', selectors: ss }; },\n        peg$c96 = \":first-child\",\n        peg$c97 = peg$literalExpectation(\":first-child\", false),\n        peg$c98 = function() { return nth(1); },\n        peg$c99 = \":last-child\",\n        peg$c100 = peg$literalExpectation(\":last-child\", false),\n        peg$c101 = function() { return nthLast(1); },\n        peg$c102 = \":nth-child(\",\n        peg$c103 = peg$literalExpectation(\":nth-child(\", false),\n        peg$c104 = function(n) { return nth(parseInt(n.join(''), 10)); },\n        peg$c105 = \":nth-last-child(\",\n        peg$c106 = peg$literalExpectation(\":nth-last-child(\", false),\n        peg$c107 = function(n) { return nthLast(parseInt(n.join(''), 10)); },\n        peg$c108 = \":\",\n        peg$c109 = peg$literalExpectation(\":\", false),\n        peg$c110 = function(c) {\n          return { type: 'class', name: c };\n        },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselectors();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1();\n        }\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c2;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c3); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifierName() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c4.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c5); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsebinaryOp() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c7;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parse_();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c9();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 126) {\n            s2 = peg$c10;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c11); }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s2 = peg$c13;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c15();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c3); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c16();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehasSelectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 36 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsehasSelector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehasSelector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsehasSelector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselectors() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 36 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseselector();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseselector();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseselector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehasSelector() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsebinaryOp();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseselector();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseselector() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequence();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parsebinaryOp();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesequence();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parsebinaryOp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesequence();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c21(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequence() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseatom();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseatom();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c24(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseatom() {\n      var s0;\n\n      var key    = peg$currPos * 36 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parsewildcard();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseattr();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsefield();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsenegation();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsematches();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseis();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsehas();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsefirstChild();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parselastChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenthChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthLastChild();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parseclass();\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsewildcard() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s1 = peg$c25;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c27(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c30(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattr() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 12,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrValue();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s5 = peg$c33;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c34); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c35(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 13,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c36.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c38;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c40(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        if (peg$c41.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrEqOps() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 14,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s1 = peg$c22;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c38;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c40(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrName() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 15,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c43;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c44); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseidentifierName();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c43;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c44); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidentifierName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c45(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseattrValue() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 16,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseattrName();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseattrEqOps();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsetype();\n              if (s5 === peg$FAILED) {\n                s5 = peg$parseregex();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c46(s1, s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseattrName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrOps();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsestring();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parsenumber();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parsepath();\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c46(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c47(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsestring() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 17,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c48;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s4 = peg$c52;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c53); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c54); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c55(s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c52;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c54); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c55(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c48;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c56(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c57;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c58); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c59.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c60); }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c52;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c53); }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c54); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s3;\n                s4 = peg$c55(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c59.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c60); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c52;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c53); }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s3;\n                  s4 = peg$c55(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s3 = peg$c57;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c56(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 18,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      if (peg$c61.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c62); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c43;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c44); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c62); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c62); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c63(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 19,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseidentifierName();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c64(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetype() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 20,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c65) {\n        s1 = peg$c65;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c66); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c67.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c68); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c67.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c68); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c71(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseflags() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 21,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (peg$c72.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c73); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c72.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseregex() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 36 + 22,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c74;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c75); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsere_character_class();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsere_escape();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsere_chars();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsere_character_class();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsere_escape();\n              if (s3 === peg$FAILED) {\n                s3 = peg$parsere_chars();\n              }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s3 = peg$c74;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c75); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseflags();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c76(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsere_character_class() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 36 + 23,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c77.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c78); }\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsere_escape();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c77.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsere_escape();\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c33;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c79(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsere_escape() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 24,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c52;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c80(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsere_chars() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 25,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c81.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c82); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c81.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c82); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c83(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefield() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 36 + 26,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s5 = peg$c43;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c44); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseidentifierName();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c43;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c44); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseidentifierName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c84(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenegation() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 27,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c85) {\n        s1 = peg$c85;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c87(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsematches() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 28,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 9) === peg$c88) {\n        s1 = peg$c88;\n        peg$currPos += 9;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c90(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseis() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 29,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c91) {\n        s1 = peg$c91;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c92); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseselectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c90(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehas() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 30,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c93) {\n        s1 = peg$c93;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c94); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsehasSelectors();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c95(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefirstChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 31,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 12) === peg$c96) {\n        s1 = peg$c96;\n        peg$currPos += 12;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c97); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c98();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parselastChild() {\n      var s0, s1;\n\n      var key    = peg$currPos * 36 + 32,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c99) {\n        s1 = peg$c99;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c100); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c101();\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 33,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 11) === peg$c102) {\n        s1 = peg$c102;\n        peg$currPos += 11;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c103); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c61.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c62); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c61.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c62); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c104(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenthLastChild() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 36 + 34,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 16) === peg$c105) {\n        s1 = peg$c105;\n        peg$currPos += 16;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c106); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c61.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c62); }\n          }\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              if (peg$c61.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c62); }\n              }\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c69;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c70); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c107(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseclass() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 36 + 35,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c108;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c109); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifierName();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c110(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      function nth(n) { return { type: 'nth-child', index: { type: 'literal', value: n } }; }\n      function nthLast(n) { return { type: 'nth-last-child', index: { type: 'literal', value: n } }; }\n      function strUnescape(s) {\n        return s.replace(/\\\\(.)/g, function(match, ch) {\n          switch(ch) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            default: return ch;\n          }\n        });\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n","/* vim: set sw=4 sts=4 : */\nimport estraverse from 'estraverse';\nimport parser from './parser.js';\n\n/**\n* @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n*/\n\nconst LEFT_SIDE = 'LEFT_SIDE';\nconst RIGHT_SIDE = 'RIGHT_SIDE';\n\n/**\n * @external AST\n * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n */\n\n/**\n * One of the rules of `grammar.pegjs`\n * @typedef {PlainObject} SelectorAST\n * @see grammar.pegjs\n*/\n\n/**\n * The `sequence` production of `grammar.pegjs`\n * @typedef {PlainObject} SelectorSequenceAST\n*/\n\n/**\n * Get the value of a property which may be multiple levels down\n * in the object.\n * @param {?PlainObject} obj\n * @param {string[]} keys\n * @returns {undefined|boolean|string|number|external:AST}\n */\nfunction getPath(obj, keys) {\n    for (let i = 0; i < keys.length; ++i) {\n        if (obj == null) { return obj; }\n        obj = obj[keys[i]];\n    }\n    return obj;\n}\n\n/**\n * Determine whether `node` can be reached by following `path`,\n * starting at `ancestor`.\n * @param {?external:AST} node\n * @param {?external:AST} ancestor\n * @param {string[]} path\n * @param {Integer} fromPathIndex\n * @returns {boolean}\n */\nfunction inPath(node, ancestor, path, fromPathIndex) {\n    let current = ancestor;\n    for (let i = fromPathIndex; i < path.length; ++i) {\n        if (current == null) {\n            return false;\n        }\n        const field = current[path[i]];\n        if (Array.isArray(field)) {\n            for (let k = 0; k < field.length; ++k) {\n                if (inPath(node, field[k], path, i + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        current = field;\n    }\n    return node === current;\n}\n\n/**\n * A generated matcher function for a selector.\n * @callback SelectorMatcher\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @returns {void}\n*/\n\n/**\n * A WeakMap for holding cached matcher functions for selectors.\n * @type {WeakMap<SelectorAST, SelectorMatcher>}\n*/\nconst MATCHER_CACHE = typeof WeakMap === 'function' ? new WeakMap : null;\n\n/**\n * Look up a matcher function for `selector` in the cache.\n * If it does not exist, generate it with `generateMatcher` and add it to the cache.\n * In engines without WeakMap, the caching is skipped and matchers are generated with every call.\n * @param {?SelectorAST} selector\n * @returns {SelectorMatcher}\n */\nfunction getMatcher(selector) {\n    if (selector == null) {\n        return () => true;\n    }\n\n    if (MATCHER_CACHE != null) {\n        let matcher = MATCHER_CACHE.get(selector);\n        if (matcher != null) {\n            return matcher;\n        }\n        matcher = generateMatcher(selector);\n        MATCHER_CACHE.set(selector, matcher);\n        return matcher;\n    }\n\n    return generateMatcher(selector);\n}\n\n/**\n * Create a matcher function for `selector`,\n * @param {?SelectorAST} selector\n * @returns {SelectorMatcher}\n */\nfunction generateMatcher(selector) {\n    switch(selector.type) {\n        case 'wildcard':\n            return () => true;\n\n        case 'identifier': {\n            const value = selector.value.toLowerCase();\n            return (node, ancestry, options) => {\n                const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n                return value === node[nodeTypeKey].toLowerCase();\n            };\n        }\n\n        case 'exactNode':\n            return (node, ancestry) => {\n                return ancestry.length === 0;\n            };\n\n        case 'field': {\n            const path = selector.name.split('.');\n            return (node, ancestry) => {\n                const ancestor = ancestry[path.length - 1];\n                return inPath(node, ancestor, path, 0);\n            };\n        }\n\n        case 'matches': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                for (let i = 0; i < matchers.length; ++i) {\n                    if (matchers[i](node, ancestry, options)) { return true; }\n                }\n                return false;\n            };\n        }\n\n        case 'compound': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                for (let i = 0; i < matchers.length; ++i) {\n                    if (!matchers[i](node, ancestry, options)) { return false; }\n                }\n                return true;\n            };\n        }\n\n        case 'not': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                for (let i = 0; i < matchers.length; ++i) {\n                    if (matchers[i](node, ancestry, options)) { return false; }\n                }\n                return true;\n            };\n        }\n\n        case 'has': {\n            const matchers = selector.selectors.map(getMatcher);\n            return (node, ancestry, options) => {\n                let result = false;\n\n                const a = [];\n                estraverse.traverse(node, {\n                    enter (node, parent) {\n                        if (parent != null) { a.unshift(parent); }\n\n                        for (let i = 0; i < matchers.length; ++i) {\n                            if (matchers[i](node, a, options)) {\n                                result = true;\n                                this.break();\n                                return;\n                            }\n                        }\n                    },\n                    leave () { a.shift(); },\n                    keys: options && options.visitorKeys,\n                    fallback: options && options.fallback || 'iteration'\n                });\n\n                return result;\n            };\n        }\n\n        case 'child': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) => {\n                if (ancestry.length > 0 && right(node, ancestry, options)) {\n                    return left(ancestry[0], ancestry.slice(1), options);\n                }\n                return false;\n            };\n        }\n\n        case 'descendant': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) => {\n                if (right(node, ancestry, options)) {\n                    for (let i = 0, l = ancestry.length; i < l; ++i) {\n                        if (left(ancestry[i], ancestry.slice(i + 1), options)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            };\n        }\n\n        case 'attribute': {\n            const path = selector.name.split('.');\n            switch (selector.operator) {\n                case void 0:\n                    return (node) => getPath(node, path) != null;\n                case '=':\n                    switch (selector.value.type) {\n                        case 'regexp':\n                            return (node) => {\n                                const p = getPath(node, path);\n                                return typeof p === 'string' && selector.value.value.test(p);\n                            };\n                        case 'literal': {\n                            const literal = `${selector.value.value}`;\n                            return (node) => literal === `${getPath(node, path)}`;\n                        }\n                        case 'type':\n                            return (node) => selector.value.value === typeof getPath(node, path);\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '!=':\n                    switch (selector.value.type) {\n                        case 'regexp':\n                            return (node) => !selector.value.value.test(getPath(node, path));\n                        case 'literal': {\n                            const literal = `${selector.value.value}`;\n                            return (node) => literal !== `${getPath(node, path)}`;\n                        }\n                        case 'type':\n                            return (node) => selector.value.value !== typeof getPath(node, path);\n                    }\n                    throw new Error(`Unknown selector value type: ${selector.value.type}`);\n                case '<=':\n                    return (node) => getPath(node, path) <= selector.value.value;\n                case '<':\n                    return (node) => getPath(node, path) < selector.value.value;\n                case '>':\n                    return (node) => getPath(node, path) > selector.value.value;\n                case '>=':\n                    return (node) => getPath(node, path) >= selector.value.value;\n            }\n            throw new Error(`Unknown operator: ${selector.operator}`);\n        }\n\n        case 'sibling': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    sibling(node, left, ancestry, LEFT_SIDE, options) ||\n                    selector.left.subject &&\n                    left(node, ancestry, options) &&\n                    sibling(node, right, ancestry, RIGHT_SIDE, options);\n        }\n\n        case 'adjacent': {\n            const left = getMatcher(selector.left);\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    adjacent(node, left, ancestry, LEFT_SIDE, options) ||\n                    selector.right.subject &&\n                    left(node, ancestry, options) &&\n                    adjacent(node, right, ancestry, RIGHT_SIDE, options);\n        }\n\n        case 'nth-child': {\n            const nth = selector.index.value;\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    nthChild(node, ancestry, nth, options);\n        }\n\n        case 'nth-last-child': {\n            const nth = -selector.index.value;\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    nthChild(node, ancestry, nth, options);\n        }\n\n        case 'class': {\n            \n            const name = selector.name.toLowerCase();\n\n            return (node, ancestry, options) => {\n                \n                if (options && options.matchClass) {\n                    return options.matchClass(selector.name, node, ancestry);\n                }\n                \n                if (options && options.nodeTypeKey) return false;    \n\n                switch(name){\n                    case 'statement':\n                        if(node.type.slice(-9) === 'Statement') return true;\n                        // fallthrough: interface Declaration <: Statement { }\n                    case 'declaration':\n                        return node.type.slice(-11) === 'Declaration';\n                    case 'pattern':\n                        if(node.type.slice(-7) === 'Pattern') return true;\n                        // fallthrough: interface Expression <: Node, Pattern { }\n                    case 'expression':\n                        return node.type.slice(-10) === 'Expression' ||\n                            node.type.slice(-7) === 'Literal' ||\n                            (\n                                node.type === 'Identifier' &&\n                                (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\n                            ) ||\n                            node.type === 'MetaProperty';\n                    case 'function':\n                        return node.type === 'FunctionDeclaration' ||\n                            node.type === 'FunctionExpression' ||\n                            node.type === 'ArrowFunctionExpression';\n                }\n                throw new Error(`Unknown class name: ${selector.name}`);\n            };\n        }\n    }\n\n    throw new Error(`Unknown selector type: ${selector.type}`);\n}\n\n/**\n * @callback TraverseOptionFallback\n * @param {external:AST} node The given node.\n * @returns {string[]} An array of visitor keys for the given node.\n */\n\n/**\n * @callback ClassMatcher\n * @param {string} className The name of the class to match.\n * @param {external:AST} node The node to match against.\n * @param {Array<external:AST>} ancestry The ancestry of the node.\n * @returns {boolean} True if the node matches the class, false if not.\n */\n\n/**\n * @typedef {object} ESQueryOptions\n * @property {string} [nodeTypeKey=\"type\"] By passing `nodeTypeKey`, we can allow other ASTs to use ESQuery.\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n * @property {ClassMatcher} [matchClass] By passing `matchClass` option, we can customize the interpretation of classes.\n */\n\n/**\n * Given a `node` and its ancestors, determine if `node` is matched\n * by `selector`.\n * @param {?external:AST} node\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @throws {Error} Unknowns (operator, class name, selector type, or\n * selector value type)\n * @returns {boolean}\n */\nfunction matches(node, selector, ancestry, options) {\n    if (!selector) { return true; }\n    if (!node) { return false; }\n    if (!ancestry) { ancestry = []; }\n\n    return getMatcher(selector)(node, ancestry, options);\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {external:AST} node The AST node to get keys.\n * @param {ESQueryOptions|undefined} options\n * @returns {string[]} Visitor keys of the node.\n */\nfunction getVisitorKeys(node, options) {\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n\n    const nodeType = node[nodeTypeKey];\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n        return options.visitorKeys[nodeType];\n    }\n    if (estraverse.VisitorKeys[nodeType]) {\n        return estraverse.VisitorKeys[nodeType];\n    }\n    if (options && typeof options.fallback === 'function') {\n        return options.fallback(node);\n    }\n    // 'iteration' fallback\n    return Object.keys(node).filter(function (key) {\n        return key !== nodeTypeKey;\n    });\n}\n\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} node The value to check.\n * @param {ESQueryOptions|undefined} options The options to use.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(node, options) {\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n    return node !== null && typeof node === 'object' && typeof node[nodeTypeKey] === 'string';\n}\n\n/**\n * Determines if the given node has a sibling that matches the\n * given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction sibling(node, matcher, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)) {\n            const startIndex = listProp.indexOf(node);\n            if (startIndex < 0) { continue; }\n            let lowerBound, upperBound;\n            if (side === LEFT_SIDE) {\n                lowerBound = 0;\n                upperBound = startIndex;\n            } else {\n                lowerBound = startIndex + 1;\n                upperBound = listProp.length;\n            }\n            for (let k = lowerBound; k < upperBound; ++k) {\n                if (isNode(listProp[k], options) && matcher(listProp[k], ancestry, options)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node has an adjacent sibling that matches\n * the given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction adjacent(node, matcher, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx < 0) { continue; }\n            if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1], options) && matcher(listProp[idx - 1], ancestry, options)) {\n                return true;\n            }\n            if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1], options) &&  matcher(listProp[idx + 1], ancestry, options)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node is the `nth` child.\n * If `nth` is negative then the position is counted\n * from the end of the list of children.\n * @param {external:AST} node\n * @param {external:AST[]} ancestry\n * @param {Integer} nth\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction nthChild(node, ancestry, nth, options) {\n    if (nth === 0) { return false; }\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)){\n            const idx = nth < 0 ? listProp.length + nth : nth - 1;\n            if (idx >= 0 && idx < listProp.length && listProp[idx] === node) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * For each selector node marked as a subject, find the portion of the\n * selector that the subject must match.\n * @param {SelectorAST} selector\n * @param {SelectorAST} [ancestor] Defaults to `selector`\n * @returns {SelectorAST[]}\n */\nfunction subjects(selector, ancestor) {\n    if (selector == null || typeof selector != 'object') { return []; }\n    if (ancestor == null) { ancestor = selector; }\n    const results = selector.subject ? [ancestor] : [];\n    const keys = Object.keys(selector);\n    for (let i = 0; i < keys.length; ++i) {\n        const p = keys[i];\n        const sel = selector[p];\n        results.push(...subjects(sel, p === 'left' ? sel : ancestor));\n    }\n    return results;\n}\n\n/**\n* @callback TraverseVisitor\n* @param {?external:AST} node\n* @param {?external:AST} parent\n* @param {external:AST[]} ancestry\n*/\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {TraverseVisitor} visitor\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction traverse(ast, selector, visitor, options) {\n    if (!selector) { return; }\n    const ancestry = [];\n    const matcher = getMatcher(selector);\n    const altSubjects = subjects(selector).map(getMatcher);\n    estraverse.traverse(ast, {\n        enter (node, parent) {\n            if (parent != null) { ancestry.unshift(parent); }\n            if (matcher(node, ancestry, options)) {\n                if (altSubjects.length) {\n                    for (let i = 0, l = altSubjects.length; i < l; ++i) {\n                        if (altSubjects[i](node, ancestry, options)) {\n                            visitor(node, parent, ancestry);\n                        }\n                        for (let k = 0, m = ancestry.length; k < m; ++k) {\n                            const succeedingAncestry = ancestry.slice(k + 1);\n                            if (altSubjects[i](ancestry[k], succeedingAncestry, options)) {\n                                visitor(ancestry[k], parent, succeedingAncestry);\n                            }\n                        }\n                    }\n                } else {\n                    visitor(node, parent, ancestry);\n                }\n            }\n        },\n        leave () { ancestry.shift(); },\n        keys: options && options.visitorKeys,\n        fallback: options && options.fallback || 'iteration'\n    });\n}\n\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction match(ast, selector, options) {\n    const results = [];\n    traverse(ast, selector, function (node) {\n        results.push(node);\n    }, options);\n    return results;\n}\n\n/**\n * Parse a selector string and return its AST.\n * @param {string} selector\n * @returns {SelectorAST}\n */\nfunction parse(selector) {\n    return parser.parse(selector);\n}\n\n/**\n * Query the code AST using the selector string.\n * @param {external:AST} ast\n * @param {string} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n}\n\nquery.parse = parse;\nquery.match = match;\nquery.traverse = traverse;\nquery.matches = matches;\nquery.query = query;\n\nexport default query;\n"],"names":["clone","exports","Syntax","VisitorOption","VisitorKeys","BREAK","SKIP","REMOVE","deepCopy","obj","key","val","ret","hasOwnProperty","Reference","parent","this","Element","node","path","wrap","ref","Controller","isNode","type","isProperty","nodeType","ObjectExpression","ObjectPattern","candidateExistsInLeaveList","leavelist","candidate","i","length","traverse","root","visitor","extendCommentRange","comment","tokens","target","array","func","diff","len","current","upperBound","token","range","extendedRange","AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","AwaitExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ChainExpression","ClassBody","ClassDeclaration","ClassExpression","ComprehensionBlock","ComprehensionExpression","ConditionalExpression","ContinueStatement","DebuggerStatement","DirectiveStatement","DoWhileStatement","EmptyStatement","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForStatement","ForInStatement","ForOfStatement","FunctionDeclaration","FunctionExpression","GeneratorExpression","Identifier","IfStatement","ImportExpression","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","Literal","LabeledStatement","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","ModuleSpecifier","NewExpression","PrivateIdentifier","Program","Property","PropertyDefinition","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchStatement","SwitchCase","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","Break","Skip","Remove","prototype","replace","remove","Array","isArray","splice","iz","j","jz","result","addToPath","push","__current","__leavelist","parents","__execute","callback","element","previous","undefined","__state","call","notify","flag","skip","__initialize","__worklist","__fallback","fallback","Object","keys","__keys","assign","create","worklist","current2","candidates","sentinel","pop","enter","Error","leave","outer","removeElem","nextElem","attachComments","tree","providedComments","cursor","comments","leadingComments","trailingComments","cloneEnvironment","module","peg$SyntaxError","message","expected","found","location","name","captureStackTrace","child","ctor","constructor","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","descriptions","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c8","peg$c11","peg$c14","peg$c18","peg$c19","ss","concat","map","peg$c23","peg$c26","peg$c29","peg$c32","peg$c34","peg$c36","peg$c37","peg$c39","peg$c40","a","peg$c41","peg$c42","peg$c44","peg$c46","op","value","operator","peg$c49","peg$c50","peg$c51","peg$c53","peg$c54","peg$c55","b","peg$c56","d","match","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c66","peg$c67","peg$c68","peg$c70","peg$c72","peg$c73","peg$c75","peg$c77","peg$c78","peg$c81","peg$c82","peg$c86","peg$c89","peg$c90","selectors","peg$c92","peg$c94","peg$c97","peg$c100","peg$c103","peg$c106","peg$c109","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","s0","s1","s2","cached","peg$resultsCache","nextPos","peg$parse_","peg$parseselectors","peg$c1","peg$parseidentifierName","test","charAt","peg$parsebinaryOp","s3","s4","s5","s6","s7","peg$parseselector","peg$parsehasSelector","left","right","peg$parsesequence","reduce","memo","rhs","subject","as","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattrName","peg$parseattrEqOps","substr","peg$parsetype","flgs","peg$parsere_character_class","peg$parsere_escape","peg$parsere_chars","peg$parseflags","RegExp","peg$parseregex","peg$parseattrOps","peg$parsestring","leadingDecimals","apply","parseFloat","peg$parsenumber","peg$parsepath","peg$parseattrValue","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parseis","peg$parsehasSelectors","peg$parsehas","nth","peg$parsefirstChild","nthLast","peg$parselastChild","parseInt","peg$parsenthChild","peg$parsenthLastChild","peg$parseclass","n","index","factory","getPath","MATCHER_CACHE","WeakMap","getMatcher","selector","matcher","get","generateMatcher","set","toLowerCase","ancestry","nodeTypeKey","split","inPath","ancestor","fromPathIndex","field","k","matchers","estraverse","unshift","shift","visitorKeys","l","_typeof","sibling","adjacent","nthChild","matchClass","getVisitorKeys","filter","side","_slicedToArray","listProp","startIndex","indexOf","lowerBound","idx","ast","altSubjects","subjects","results","sel","_toConsumableArray","m","succeedingAncestry","parser","query","matches"],"mappings":"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"}