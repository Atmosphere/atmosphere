{
  "version": 3,
  "sources": ["../../src/regex.js", "../../src/utils-internals.js", "../../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js", "../../src/atomic.js", "../../src/pattern.js", "../../src/utils.js", "../../src/backcompat.js", "../../src/flag-n.js", "../../src/flag-x.js", "../../src/subclass.js", "../../src/subroutines.js"],
  "sourcesContent": ["import {atomic, possessive} from './atomic.js';\nimport {backcompatPlugin} from './backcompat.js';\nimport {flagNPreprocessor} from './flag-n.js';\nimport {clean, flagXPreprocessor} from './flag-x.js';\nimport {Pattern, pattern} from './pattern.js';\nimport {RegExpSubclass} from './subclass.js';\nimport {subroutines} from './subroutines.js';\nimport {adjustNumberedBackrefs, CharClassContext, containsCharClassUnion, countCaptures, enclosedTokenCharClassContexts, enclosedTokenRegexContexts, envSupportsFlagGroups, envSupportsFlagV, escapeV, getBreakoutChar, getEndContextForIncompleteExpression, preprocess, RegexContext, sandboxLoneCharClassCaret, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls} from './utils.js';\nimport {Context, hasUnescaped, replaceUnescaped} from 'regex-utilities';\n\n/**\n@typedef {string | RegExp | Pattern | number} InterpolatedValue\n@typedef {{\n  flags?: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n}} PluginData\n@typedef {{\n  pattern: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n}} PluginResult\n@typedef {TemplateStringsArray | {raw: Array<string>}} RawTemplate\n@typedef {{\n  flags?: string;\n  subclass?: boolean;\n  plugins?: Array<(expression: string, data: PluginData) => PluginResult>;\n  unicodeSetsPlugin?: ((expression: string, data: PluginData) => PluginResult) | null;\n  disable?: {\n    x?: boolean;\n    n?: boolean;\n    v?: boolean;\n    atomic?: boolean;\n    subroutines?: boolean;\n  };\n  force?: {\n    v?: boolean;\n  };\n}} RegexTagOptions\n*/\n/**\n@template T\n@typedef RegexTag\n@type {{\n  (template: RawTemplate, ...substitutions: ReadonlyArray<InterpolatedValue>): T;\n  (flags?: string): RegexTag<T>;\n  (options: RegexTagOptions & {subclass?: false}): RegexTag<T>;\n  (options: RegexTagOptions & {subclass: true}): RegexTag<RegExpSubclass>;\n}}\n*/\n/**\nTemplate tag for constructing a regex with extended syntax and context-aware interpolation of\nregexes, strings, and patterns.\n\nCan be called in several ways:\n1. `` regex`\u2026` `` - Regex pattern as a raw string.\n2. `` regex('gi')`\u2026` `` - To specify flags.\n3. `` regex({flags: 'gi'})`\u2026` `` - With options.\n@type {RegexTag<RegExp>}\n*/\nconst regex = (first, ...substitutions) => {\n  // Given a template\n  if (Array.isArray(first?.raw)) {\n    return regexFromTemplate({}, first, ...substitutions);\n  // Given flags\n  } else if ((typeof first === 'string' || first === undefined) && !substitutions.length) {\n    return regexFromTemplate.bind(null, {flags: first ?? ''});\n  // Given an options object\n  } else if ({}.toString.call(first) === '[object Object]' && !substitutions.length) {\n    return regexFromTemplate.bind(null, first);\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...substitutions])}`);\n};\n\n/**\n@template T\n@typedef RegexFromTemplate\n@type {{\n  (options: RegexTagOptions, template: RawTemplate, ...substitutions: ReadonlyArray<InterpolatedValue>) : T;\n}}\n*/\n/**\nReturns a RegExp from a template and substitutions to fill the template holes.\n@type {RegexFromTemplate<RegExp>}\n*/\nconst regexFromTemplate = (options, template, ...substitutions) => {\n  const opts = getOptions(options);\n  const prepped = runPreprocessors(template, substitutions, opts);\n\n  let precedingCaptures = 0;\n  let expression = '';\n  let runningContext;\n  // Intersperse raw template strings and substitutions\n  prepped.template.raw.forEach((raw, i) => {\n    const hasNonEmptyRawBoundary = !!(prepped.template.raw[i] || prepped.template.raw[i + 1]);\n    // Even with flag n enabled, we might have named captures\n    precedingCaptures += countCaptures(raw);\n    // Sandbox `\\0` in character classes. Not needed outside character classes because in other\n    // cases a following interpolated value would always be atomized\n    expression += sandboxUnsafeNulls(raw, Context.CHAR_CLASS);\n    runningContext = getEndContextForIncompleteExpression(expression, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (i < prepped.template.raw.length - 1) {\n      const substitution = prepped.substitutions[i];\n      expression += interpolate(\n        substitution,\n        opts.flags,\n        regexContext,\n        charClassContext,\n        hasNonEmptyRawBoundary,\n        precedingCaptures\n      );\n      if (substitution instanceof RegExp) {\n        precedingCaptures += countCaptures(substitution.source);\n      } else if (substitution instanceof Pattern) {\n        precedingCaptures += countCaptures(String(substitution));\n      }\n    }\n  });\n\n  const plugged = runPlugins(expression, opts);\n  expression = plugged.pattern;\n  try {\n    return opts.subclass ?\n      new RegExpSubclass(expression, opts.flags, {hiddenCaptures: plugged.hiddenCaptures}) :\n      new RegExp(expression, opts.flags);\n  } catch (err) {\n    // Improve DX by always including the generated source in the error message. Some browsers\n    // include it automatically, but not Firefox or Safari\n    const stripped = err.message.replace(/ \\/.+\\/[a-z]*:/, '');\n    err.message = `${stripped}: /${expression}/${opts.flags}`;\n    throw err;\n  }\n};\n\n/**\nReturns the processed expression and flags as strings.\n@param {string} expression\n@param {RegexTagOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n}}\n*/\nfunction rewrite(expression = '', options) {\n  const opts = getOptions(options);\n  if (opts.subclass) {\n    throw new Error('Cannot use option subclass');\n  }\n  return {\n    // NOTE: Since `pattern` is a Regex+ export with special meaning, the term `expression` is used\n    // in code to refer to regex source strings, except in the public API\n    pattern: runPlugins(\n      runPreprocessors({raw: [expression]}, [], opts).template.raw[0],\n      opts\n    ).pattern,\n    flags: opts.flags,\n  };\n}\n\n/**\nReturns a complete set of options, with default values set for options that weren't provided, and\nsome options augmented for use.\n@param {RegexTagOptions} [options]\n@returns {Required<RegexTagOptions>}\n*/\nfunction getOptions(options) {\n  const opts = {\n    flags: '',\n    subclass: false,\n    plugins: [],\n    unicodeSetsPlugin: backcompatPlugin,\n    disable: {/* n, v, x, atomic, subroutines */},\n    force: {/* v */},\n    ...options,\n  };\n  if (/[nuvx]/.test(opts.flags)) {\n    throw new Error('Implicit flags v/u/x/n cannot be explicitly added');\n  }\n  const useFlagV = opts.force.v || (opts.disable.v ? false : envSupportsFlagV);\n  opts.flags += useFlagV ? 'v' : 'u';\n  if (useFlagV) {\n    opts.unicodeSetsPlugin = null;\n  }\n  return opts;\n}\n\n/**\n@param {RawTemplate} template\n@param {ReadonlyArray<InterpolatedValue>} substitutions\n@param {Required<RegexTagOptions>} options\n@returns {{\n  template: RawTemplate;\n  substitutions: ReadonlyArray<InterpolatedValue>;\n}}\n*/\nfunction runPreprocessors(template, substitutions, options) {\n  const preprocessors = [];\n  // Implicit flag x is handled first because otherwise some regex syntax (if unescaped) within\n  // comments could cause problems when parsing\n  if (!options.disable.x) {\n    preprocessors.push(flagXPreprocessor);\n  }\n  // Implicit flag n is a preprocessor because capturing groups affect backreference rewriting in\n  // both interpolation and plugins\n  if (!options.disable.n) {\n    preprocessors.push(flagNPreprocessor);\n  }\n  for (const pp of preprocessors) {\n    ({template, substitutions} = preprocess(template, substitutions, pp, options));\n  }\n  return {\n    template,\n    substitutions,\n  };\n}\n\n/**\n@param {string} expression\n@param {Required<RegexTagOptions>} options\n@returns {Required<PluginResult>}\n*/\nfunction runPlugins(expression, {flags, plugins, unicodeSetsPlugin, disable}) {\n  let hiddenCaptures = [];\n  [ ...plugins, // Run first, so provided plugins can output extended syntax\n    ...(disable.subroutines ? [] : [subroutines]),\n    ...(disable.atomic      ? [] : [possessive, atomic]),\n    ...(disable.x           ? [] : [clean]),\n    // Run last, so it doesn't have to worry about parsing extended syntax\n    ...(!unicodeSetsPlugin  ? [] : [unicodeSetsPlugin]),\n  ].forEach(plugin => {\n    const result = plugin(expression, {flags, hiddenCaptures});\n    if (typeof result?.pattern !== 'string') {\n      throw new Error('Plugin must return an object with a string property \"pattern\"');\n    }\n    expression = result.pattern;\n    if (result.hiddenCaptures) {\n      hiddenCaptures = result.hiddenCaptures;\n    }\n  });\n  return {\n    pattern: expression,\n    hiddenCaptures,\n  };\n}\n\n/**\n@param {InterpolatedValue} value\n@param {string} flags\n@param {string} regexContext\n@param {string} charClassContext\n@param {boolean} hasNonEmptyRawBoundary\n@param {number} precedingCaptures\n@returns {string}\n*/\nfunction interpolate(value, flags, regexContext, charClassContext, hasNonEmptyRawBoundary, precedingCaptures) {\n  if (value instanceof RegExp) {\n    if (regexContext !== RegexContext.DEFAULT) {\n      throw new Error('Cannot interpolate a RegExp at this position because the syntax context does not match');\n    }\n    const transformed = transformForLocalFlags(value, flags);\n    const backrefsAdjusted = adjustNumberedBackrefs(transformed, precedingCaptures);\n    // Sandbox and atomize\n    return wrapIfUnsafe(backrefsAdjusted);\n  }\n\n  if (\n    regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN ||\n    charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN\n  ) {\n    // Throw in all cases, but only *need* to handle a preceding unescaped backslash (which would\n    // break sandboxing) since other errors would be handled by the invalid generated regex syntax\n    throw new Error('Interpolation preceded by invalid incomplete token');\n  }\n\n  if (\n    typeof value === 'number' &&\n    (regexContext === RegexContext.ENCLOSED_U || charClassContext === CharClassContext.ENCLOSED_U)\n  ) {\n    return value.toString(16);\n  }\n\n  const isPattern = value instanceof Pattern;\n  value = String(value);\n  const escapedValue = isPattern ? null : escapeV(\n    value,\n    regexContext === RegexContext.CHAR_CLASS ? Context.CHAR_CLASS : Context.DEFAULT\n  );\n  // Checks `escapedValue` in addition to patterns since potential breakout char `>` isn't escaped\n  const breakoutChar = getBreakoutChar(escapedValue || value, regexContext, charClassContext);\n  if (breakoutChar) {\n    throw new Error(`Unescaped stray \"${breakoutChar}\" in the interpolated value would have side effects outside it`);\n  }\n\n  if (\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    regexContext === RegexContext.GROUP_NAME ||\n    enclosedTokenRegexContexts.has(regexContext) ||\n    enclosedTokenCharClassContexts.has(charClassContext)\n  ) {\n    return isPattern ? value : escapedValue;\n  }\n  if (regexContext === RegexContext.CHAR_CLASS) {\n    if (isPattern) {\n      if (hasUnescaped(value, '^-|^&&|-$|&&$')) {\n        // Sandboxing so we don't change the chars outside the pattern into being part of an\n        // operation they didn't initiate. Same problem as starting a pattern with a quantifier\n        throw new Error('Cannot use range or set operator at boundary of interpolated pattern; move the operation into the pattern or the operator outside of it');\n      }\n      const sandboxedValue = sandboxLoneCharClassCaret(sandboxLoneDoublePunctuatorChar(value));\n      // Atomize via nested character class `[\u2026]` if it contains implicit or explicit union (check\n      // the unadjusted value)\n      return containsCharClassUnion(value) ? `[${sandboxedValue}]` : sandboxUnsafeNulls(sandboxedValue);\n    }\n    // Atomize via nested character class `[\u2026]` if more than one node\n    return containsCharClassUnion(escapedValue) ? `[${escapedValue}]` : escapedValue;\n  }\n  if (isPattern) {\n    // Sandbox and atomize\n    return wrapIfUnsafe(value);\n  }\n  // Sandbox and atomize, but avoid noise from noncapturing group if unnecessary (safe to avoid\n  // because interpolated patterns and regexes are always wrapped)\n  return hasNonEmptyRawBoundary ? `(?:${escapedValue})` : escapedValue;\n}\n\n/**\n@param {string} str\n@returns {string}\n*/\nfunction wrapIfUnsafe(str) {\n  return (str.startsWith('(') && str.endsWith(')')) ? str : `(?:${str})`;\n}\n\n/**\n@param {RegExp} re\n@param {string} outerFlags\n@returns {string}\n*/\nfunction transformForLocalFlags(re, outerFlags) {\n  /** @type {{i: boolean | null; m: boolean | null; s: boolean | null;}} */\n  const modFlagsObj = {\n    i: null,\n    m: null,\n    s: null,\n  };\n  const newlines = '\\\\n\\\\r\\\\u2028\\\\u2029';\n  let value = re.source;\n  if (re.ignoreCase !== outerFlags.includes('i')) {\n    if (envSupportsFlagGroups) {\n      modFlagsObj.i = re.ignoreCase;\n    } else {\n      throw new Error('Flag groups not supported, so flag i on the outer and interpolated regex must match');\n    }\n  }\n  if (re.dotAll !== outerFlags.includes('s')) {\n    if (envSupportsFlagGroups) {\n      modFlagsObj.s = re.dotAll;\n    } else {\n      value = replaceUnescaped(value, '\\\\.', (re.dotAll ? '[^]' : `[^${newlines}]`), Context.DEFAULT);\n    }\n  }\n  if (re.multiline !== outerFlags.includes('m')) {\n    if (envSupportsFlagGroups) {\n      modFlagsObj.m = re.multiline;\n    } else {\n      value = replaceUnescaped(value, '\\\\^', (re.multiline ? `(?<=^|[${newlines}])` : '(?<![^])'), Context.DEFAULT);\n      value = replaceUnescaped(value, '\\\\$', (re.multiline ? `(?=$|[${newlines}])` : '(?![^])'), Context.DEFAULT);\n    }\n  }\n  if (envSupportsFlagGroups) {\n    const keys = Object.keys(modFlagsObj);\n    let modifier = keys.filter(k => modFlagsObj[k] === true).join('');\n    const modOff = keys.filter(k => modFlagsObj[k] === false).join('');\n    if (modOff) {\n      modifier += `-${modOff}`;\n    }\n    if (modifier) {\n      return `(?${modifier}:${value})`;\n    }\n  }\n  return value;\n}\n\nexport {\n  pattern,\n  regex,\n  rewrite,\n};\n", "// Separating some utils for improved tree shaking of the `./internals` export\n\nconst noncapturingDelim = String.raw`\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))`;\n\n/**\nUpdates the array in place by incrementing each value greater than or equal to the threshold.\n@param {Array<number>} arr\n@param {number} threshold\n*/\nfunction incrementIfAtLeast(arr, threshold) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= threshold) {\n      arr[i]++;\n    }\n  }\n}\n\n/**\n@param {string} str\n@param {number} pos\n@param {string} oldValue\n@param {string} newValue\n@returns {string}\n*/\nfunction spliceStr(str, pos, oldValue, newValue) {\n  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);\n}\n\nexport {\n  incrementIfAtLeast,\n  noncapturingDelim,\n  spliceStr,\n};\n", "// Constant properties for tracking regex syntax context\nexport const Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n// \u2192 '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nexport function replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nexport function forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nexport function execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nexport function hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nexport function getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n", "import {incrementIfAtLeast, noncapturingDelim, spliceStr} from './utils-internals.js';\nimport {Context, replaceUnescaped} from 'regex-utilities';\n/**\n@import {PluginData, PluginResult} from './regex.js';\n*/\n\nconst atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?.`, 'gsu');\n\n/**\nApply transformations for atomic groups: `(?>\u2026)`.\n@param {string} expression\n@param {PluginData} [data]\n@returns {Required<PluginResult>}\n*/\nfunction atomic(expression, data) {\n  const hiddenCaptures = data?.hiddenCaptures ?? [];\n  // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>\n  let captureTransfers = data?.captureTransfers ?? new Map();\n  if (!/\\(\\?>/.test(expression)) {\n    return {\n      pattern: expression,\n      captureTransfers,\n      hiddenCaptures,\n    };\n  }\n\n  const aGDelim = '(?>';\n  const emulatedAGDelim = '(?:(?=(';\n  const captureNumMap = [0];\n  const addedHiddenCaptures = [];\n  let numCapturesBeforeAG = 0;\n  let numAGs = 0;\n  let aGPos = NaN;\n  let hasProcessedAG;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;\n    while (match = atomicPluginToken.exec(expression)) {\n      const {0: m, index, groups: {capturingStart, noncapturingStart}} = match;\n      if (m === '[') {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n\n        if (m === aGDelim && !inAG) {\n          aGPos = index;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          } else {\n            numCapturesBeforeAG++;\n            captureNumMap.push(numCapturesBeforeAG + numAGs);\n          }\n        } else if (m === ')' && inAG) {\n          if (!numGroupsOpenInAG) {\n            numAGs++;\n            const addedCaptureNum = numCapturesBeforeAG + numAGs;\n            // Replace `expression` and use `<$$N>` as a temporary wrapper for the backref so it\n            // can avoid backref renumbering afterward. Wrap the whole substitution (including the\n            // lookahead and following backref) in a noncapturing group to handle following\n            // quantifiers and literal digits\n            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${\n                expression.slice(aGPos + aGDelim.length, index)\n              }))<$$${addedCaptureNum}>)${expression.slice(index + 1)}`;\n            hasProcessedAG = true;\n            addedHiddenCaptures.push(addedCaptureNum);\n            incrementIfAtLeast(hiddenCaptures, addedCaptureNum);\n            if (captureTransfers.size) {\n              const newCaptureTransfers = new Map();\n              captureTransfers.forEach((from, to) => {\n                newCaptureTransfers.set(\n                  to >= addedCaptureNum ? to + 1 : to,\n                  from.map(f => f >= addedCaptureNum ? f + 1 : f)\n                );\n              });\n              captureTransfers = newCaptureTransfers;\n            }\n            break;\n          }\n          numGroupsOpenInAG--;\n        }\n\n      } else if (m === ']') {\n        numCharClassesOpen--;\n      }\n    }\n  // Start over from the beginning of the atomic group's contents, in case the processed group\n  // contains additional atomic groups\n  } while (hasProcessedAG);\n\n  hiddenCaptures.push(...addedHiddenCaptures);\n\n  // Second pass to adjust numbered backrefs\n  expression = replaceUnescaped(\n    expression,\n    String.raw`\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>`,\n    ({0: m, groups: {backrefNum, wrappedBackrefNum}}) => {\n      if (backrefNum) {\n        const bNum = +backrefNum;\n        if (bNum > captureNumMap.length - 1) {\n          throw new Error(`Backref \"${m}\" greater than number of captures`);\n        }\n        return `\\\\${captureNumMap[bNum]}`;\n      }\n      return `\\\\${wrappedBackrefNum}`;\n    },\n    Context.DEFAULT\n  );\n\n  return {\n    pattern: expression,\n    captureTransfers,\n    hiddenCaptures,\n  };\n}\n\nconst baseQuantifier = String.raw`(?:[?*+]|\\{\\d+(?:,\\d*)?\\})`;\n// Complete tokenizer for base syntax; doesn't (need to) know about character-class-only syntax\nconst possessivePluginToken = new RegExp(String.raw`\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nTransform posessive quantifiers into atomic groups. The posessessive quantifiers are:\n`?+`, `*+`, `++`, `{N}+`, `{N,}+`, `{N,N}+`.\nThis follows Java, PCRE, Perl, and Python.\nPossessive quantifiers in Oniguruma and Onigmo are only: `?+`, `*+`, `++`.\n@param {string} expression\n@returns {PluginResult}\n*/\nfunction possessive(expression) {\n  if (!(new RegExp(`${baseQuantifier}\\\\+`).test(expression))) {\n    return {\n      pattern: expression,\n    };\n  }\n\n  const openGroupIndices = [];\n  let lastGroupIndex = null;\n  let lastCharClassIndex = null;\n  let lastToken = '';\n  let numCharClassesOpen = 0;\n  let match;\n  possessivePluginToken.lastIndex = 0;\n  while (match = possessivePluginToken.exec(expression)) {\n    const {0: m, index, groups: {qBase, qMod, invalidQ}} = match;\n    if (m === '[') {\n      if (!numCharClassesOpen) {\n        lastCharClassIndex = index;\n      }\n      numCharClassesOpen++;\n    } else if (m === ']') {\n      if (numCharClassesOpen) {\n        numCharClassesOpen--;\n      // Unmatched `]`\n      } else {\n        lastCharClassIndex = null;\n      }\n    } else if (!numCharClassesOpen) {\n\n      if (qMod === '+' && lastToken && !lastToken.startsWith('(')) {\n        // Invalid following quantifier would become valid via the wrapping group\n        if (invalidQ) {\n          throw new Error(`Invalid quantifier \"${m}\"`);\n        }\n        let charsAdded = -1; // -1 for removed trailing `+`\n        // Possessivizing fixed repetition quantifiers like `{2}` does't change their behavior, so\n        // avoid doing so (convert them to greedy)\n        if (/^\\{\\d+\\}$/.test(qBase)) {\n          expression = spliceStr(expression, index + qBase.length, qMod, '');\n        } else {\n          if (lastToken === ')' || lastToken === ']') {\n            const nodeIndex = lastToken === ')' ? lastGroupIndex : lastCharClassIndex;\n            // Unmatched `)` would break out of the wrapping group and mess with handling.\n            // Unmatched `]` wouldn't be a problem, but it's unnecessary to have dedicated support\n            // for unescaped `]++` since this won't work with flag u or v anyway\n            if (nodeIndex === null) {\n              throw new Error(`Invalid unmatched \"${lastToken}\"`);\n            }\n            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;\n          } else {\n            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;\n          }\n          charsAdded += 4; // `(?>)`\n        }\n        possessivePluginToken.lastIndex += charsAdded;\n      } else if (m[0] === '(') {\n        openGroupIndices.push(index);\n      } else if (m === ')') {\n        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;\n      }\n\n    }\n    lastToken = m;\n  }\n\n  return {\n    pattern: expression,\n  };\n}\n\nexport {\n  atomic,\n  possessive,\n};\n", "class Pattern {\n  #value;\n  /** @param {string} value */\n  constructor(value) {\n    this.#value = value;\n  }\n  /** @returns {string} */\n  toString() {\n    return String(this.#value);\n  }\n}\n\n/**\nReturns a value that can be interpolated into a `regex` template string without having its special\ncharacters escaped.\n\nCan be called as a function or template tag:\n- `pattern(value)` - String or value coerced to string.\n- `` pattern`\u2026` `` - Same as ``pattern(String.raw`\u2026`)``.\n\n@overload\n@param {string | number} value\n@returns {Pattern}\n\n@overload\n@param {TemplateStringsArray} template\n@param {...string} substitutions\n@returns {Pattern}\n*/\nfunction pattern(first, ...substitutions) {\n  if (Array.isArray(first?.raw)) {\n    return new Pattern(\n      // Intersperse raw template strings and substitutions\n      first.raw.flatMap((raw, i) => i < first.raw.length - 1 ? [raw, substitutions[i]] : raw).join('')\n    );\n  } else if (!substitutions.length) {\n    return new Pattern(first === undefined ? '' : first);\n  }\n  throw new Error(`Unexpected arguments: ${JSON.stringify([first, ...substitutions])}`);\n}\n\nexport {\n  Pattern,\n  pattern,\n};\n", "import {Pattern, pattern} from './pattern.js';\nimport {Context, forEachUnescaped, replaceUnescaped} from 'regex-utilities';\n/**\n@import {InterpolatedValue, RawTemplate, RegexTagOptions} from './regex.js';\n*/\n\nconst RegexContext = {\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n  ENCLOSED_P: 'ENCLOSED_P',\n  ENCLOSED_U: 'ENCLOSED_U',\n  GROUP_NAME: 'GROUP_NAME',\n  INTERVAL_QUANTIFIER: 'INTERVAL_QUANTIFIER',\n  INVALID_INCOMPLETE_TOKEN: 'INVALID_INCOMPLETE_TOKEN',\n};\n\nconst CharClassContext = {\n  DEFAULT: 'DEFAULT',\n  ENCLOSED_P: 'ENCLOSED_P',\n  ENCLOSED_Q: 'ENCLOSED_Q',\n  ENCLOSED_U: 'ENCLOSED_U',\n  INVALID_INCOMPLETE_TOKEN: 'INVALID_INCOMPLETE_TOKEN',\n  RANGE: 'RANGE',\n};\n\nconst enclosedTokenRegexContexts = new Set([\n  RegexContext.ENCLOSED_P,\n  RegexContext.ENCLOSED_U,\n]);\n\nconst enclosedTokenCharClassContexts = new Set([\n  CharClassContext.ENCLOSED_P,\n  CharClassContext.ENCLOSED_Q,\n  CharClassContext.ENCLOSED_U,\n]);\n\nconst envSupportsFlagGroups = (() => {\n  try {\n    new RegExp('(?i:)');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nconst envSupportsFlagV = (() => {\n  try {\n    new RegExp('', 'v');\n  } catch {\n    return false;\n  }\n  return true;\n})();\n\nconst doublePunctuatorChars = '&!#$%*+,.:;<=>?@^`~';\nconst namedCapturingDelim = String.raw`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst capturingDelim = String.raw`\\((?!\\?)(?!(?<=\\(\\?\\()DEFINE\\))|${namedCapturingDelim}`;\n\n/**\n@param {string} expression\n@param {number} precedingCaptures\n@returns {string}\n*/\nfunction adjustNumberedBackrefs(expression, precedingCaptures) {\n  return replaceUnescaped(\n    expression,\n    String.raw`\\\\(?<num>[1-9]\\d*)`,\n    ({groups: {num}}) => `\\\\${+num + precedingCaptures}`,\n    Context.DEFAULT\n  );\n}\n\n// Properties of strings as of ES2024\nconst stringPropertyNames = [\n  'Basic_Emoji',\n  'Emoji_Keycap_Sequence',\n  'RGI_Emoji_Modifier_Sequence',\n  'RGI_Emoji_Flag_Sequence',\n  'RGI_Emoji_Tag_Sequence',\n  'RGI_Emoji_ZWJ_Sequence',\n  'RGI_Emoji',\n].join('|');\nconst charClassUnionToken = new RegExp(String.raw`\n\\\\(?: c[A-Za-z]\n  | p\\{(?<pStrProp>${stringPropertyNames})\\}\n  | [pP]\\{[^\\}]+\\}\n  | (?<qStrProp>q)\n  | u(?:[A-Fa-f\\d]{4}|\\{[A-Fa-f\\d]+\\})\n  | x[A-Fa-f\\d]{2}\n  | .\n)\n| --\n| &&\n| .\n`.replace(/\\s+/g, ''), 'gsu');\n\n// Assumes flag v and doesn't worry about syntax errors that are caught by it\nfunction containsCharClassUnion(charClassPattern) {\n  // Return `true` if it contains:\n  // - `\\p` (lowercase only) and the name is a property of strings (case sensitive).\n  // - `\\q`.\n  // - Two single-char-matching tokens in sequence.\n  // - One single-char-matching token followed immediately by unescaped `[`.\n  // - One single-char-matching token preceded immediately by unescaped `]`.\n  // Else, `false`.\n  // Ranges with `-` create a single token.\n  // Subtraction and intersection with `--` and `&&` create a single token.\n  // Supports any number of nested classes\n  let hasFirst = false;\n  let lastM;\n  for (const {0: m, groups} of charClassPattern.matchAll(charClassUnionToken)) {\n    if (groups.pStrProp || groups.qStrProp) {\n      return true;\n    }\n    if (m === '[' && hasFirst) {\n      return true;\n    }\n    if (['-', '--', '&&'].includes(m)) {\n      hasFirst = false;\n    } else if (m !== '[' && m !== ']') {\n      if (hasFirst || lastM === ']') {\n        return true;\n      }\n      hasFirst = true;\n    }\n    lastM = m;\n  }\n  return false;\n}\n\n/**\n@param {string} expression\n@returns {number}\n*/\nfunction countCaptures(expression) {\n  let num = 0;\n  forEachUnescaped(expression, capturingDelim, () => num++, Context.DEFAULT);\n  return num;\n}\n\n/**\nEscape special characters for the given context, assuming flag v.\n@param {string} str String to escape\n@param {'DEFAULT' | 'CHAR_CLASS'} context `Context` option from lib `regex-utilities`\n@returns {string} Escaped string\n*/\nfunction escapeV(str, context) {\n  if (context === Context.CHAR_CLASS) {\n    // Escape all double punctuators (including ^, which is special on its own in the first\n    // position) in case they're bordered by the same character in or outside of the escaped string\n    return str.replace(new RegExp(String.raw`[()\\[\\]{}|\\\\/\\-${doublePunctuatorChars}]`, 'g'), '\\\\$&');\n  }\n  return str.replace(/[()\\[\\]{}|\\\\^$*+?.]/g, '\\\\$&');\n}\n\n// Look for characters that would change the meaning of subsequent tokens outside an interpolated value\nfunction getBreakoutChar(expression, regexContext, charClassContext) {\n  const escapesRemoved = expression.replace(/\\\\./gsu, '');\n  // Trailing unescaped `\\`; checking `.includes('\\\\')` would also work\n  if (escapesRemoved.endsWith('\\\\')) {\n    return '\\\\';\n  }\n  if (regexContext === RegexContext.DEFAULT) {\n    // Unbalanced `[` or `]` are also errors but don't breakout; they're caught by the wrapper\n    return getUnbalancedChar(escapesRemoved, '(', ')');\n  } else if (\n    regexContext === RegexContext.CHAR_CLASS &&\n    !enclosedTokenCharClassContexts.has(charClassContext)\n  ) {\n    return getUnbalancedChar(escapesRemoved, '[', ']');\n  } else if (\n    regexContext === RegexContext.INTERVAL_QUANTIFIER ||\n    enclosedTokenRegexContexts.has(regexContext) ||\n    enclosedTokenCharClassContexts.has(charClassContext)\n  ) {\n    if (escapesRemoved.includes('}')) {\n      return '}';\n    }\n  } else if (regexContext === RegexContext.GROUP_NAME) {\n    if (escapesRemoved.includes('>')) {\n      return '>';\n    }\n  }\n  return '';\n}\n\nconst contextToken = new RegExp(String.raw`\n(?<groupN>\\(\\?<(?![=!])|\\\\[gk]<)\n| (?<enclosedPU>\\\\[pPu]\\{)\n| (?<enclosedQ>\\\\q\\{)\n| (?<intervalQ>\\{)\n| (?<incompleteT>\\\\(?: $\n  | c(?![A-Za-z])\n  | u(?![A-Fa-f\\d]{4})[A-Fa-f\\d]{0,3}\n  | x(?![A-Fa-f\\d]{2})[A-Fa-f\\d]?\n  )\n)\n| --\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\n@typedef {{\n  regexContext: string;\n  charClassContext: string;\n  charClassDepth: number;\n  lastPos: number;\n}} RunningContext\n*/\n/**\nAccepts and returns its full state so it doesn't have to reprocess parts that have already been\nseen. Assumes flag v and doesn't worry about syntax errors that are caught by it.\n@param {string} incompleteExpression\n@param {Partial<RunningContext>} [runningContext]\n@returns {RunningContext}\n*/\nfunction getEndContextForIncompleteExpression(incompleteExpression, runningContext) {\n  let {regexContext, charClassContext, charClassDepth, lastPos} = {\n    regexContext: RegexContext.DEFAULT,\n    charClassContext: CharClassContext.DEFAULT,\n    charClassDepth: 0,\n    lastPos: 0,\n    ...runningContext,\n  };\n  contextToken.lastIndex = lastPos;\n  let match;\n  while (match = contextToken.exec(incompleteExpression)) {\n    const {0: m, groups: {groupN, enclosedPU, enclosedQ, intervalQ, incompleteT}} = match;\n    if (m === '[') {\n      charClassDepth++;\n      regexContext = RegexContext.CHAR_CLASS;\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (m === ']' && regexContext === RegexContext.CHAR_CLASS) {\n      if (charClassDepth) {\n        charClassDepth--;\n      }\n      if (!charClassDepth) {\n        regexContext = RegexContext.DEFAULT;\n      }\n      charClassContext = CharClassContext.DEFAULT;\n    } else if (regexContext === RegexContext.CHAR_CLASS) {\n      if (incompleteT) {\n        charClassContext = CharClassContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (m === '-') {\n        charClassContext = CharClassContext.RANGE;\n      } else if (enclosedPU) {\n        charClassContext = m[1] === 'u' ? CharClassContext.ENCLOSED_U : CharClassContext.ENCLOSED_P;\n      } else if (enclosedQ) {\n        charClassContext = CharClassContext.ENCLOSED_Q;\n      } else if (\n        (m === '}' && enclosedTokenCharClassContexts.has(charClassContext)) ||\n        // Don't continue in these contexts since we've advanced another token\n        charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN ||\n        charClassContext === CharClassContext.RANGE\n      ) {\n        charClassContext = CharClassContext.DEFAULT;\n      }\n    } else {\n      if (incompleteT) {\n        regexContext = RegexContext.INVALID_INCOMPLETE_TOKEN;\n      } else if (groupN) {\n        regexContext = RegexContext.GROUP_NAME;\n      } else if (enclosedPU) {\n        regexContext = m[1] === 'u' ? RegexContext.ENCLOSED_U : RegexContext.ENCLOSED_P;\n      } else if (intervalQ) {\n        regexContext = RegexContext.INTERVAL_QUANTIFIER;\n      } else if (\n        (m === '>' && regexContext === RegexContext.GROUP_NAME) ||\n        (m === '}' && (regexContext === RegexContext.INTERVAL_QUANTIFIER || enclosedTokenRegexContexts.has(regexContext))) ||\n        // Don't continue in this context since we've advanced another token\n        regexContext === RegexContext.INVALID_INCOMPLETE_TOKEN\n       ) {\n        regexContext = RegexContext.DEFAULT;\n      }\n    }\n  }\n  return {\n    regexContext,\n    charClassContext,\n    charClassDepth,\n    lastPos: incompleteExpression.length,\n  };\n}\n\n// No special handling for escaped versions of the characters\nfunction getUnbalancedChar(expression, leftChar, rightChar) {\n  let numOpen = 0;\n  for (const [m] of expression.matchAll(new RegExp(`[${escapeV(leftChar + rightChar, Context.CHAR_CLASS)}]`, 'g'))) {\n    numOpen += m === leftChar ? 1 : -1;\n    if (numOpen < 0) {\n      return rightChar;\n    }\n  }\n  if (numOpen > 0) {\n    return leftChar;\n  }\n  return '';\n}\n\n/**\n@typedef {InterpolatedValue} InterpolatedValue\n@typedef {RawTemplate} RawTemplate\n@typedef {RegexTagOptions} RegexTagOptions\n@typedef {(\n  value: InterpolatedValue,\n  runningContext: RunningContext,\n  options: Required<RegexTagOptions>\n) => {\n  transformed: string;\n  runningContext: RunningContext;\n}} Preprocessor\n*/\n/**\nReturns transformed versions of a template and substitutions, using the given preprocessor. Only\nprocesses substitutions that are instanceof `Pattern`.\n@param {RawTemplate} template\n@param {ReadonlyArray<InterpolatedValue>} substitutions\n@param {Preprocessor} preprocessor\n@param {Required<RegexTagOptions>} options\n@returns {{template: RawTemplate; substitutions: ReadonlyArray<InterpolatedValue>;}}\n*/\nfunction preprocess(template, substitutions, preprocessor, options) {\n  let /** @type {RawTemplate} */ newTemplate = {raw: []};\n  let newSubstitutions = [];\n  let runningContext;\n  template.raw.forEach((raw, i) => {\n    const result = preprocessor(raw, {...runningContext, lastPos: 0}, options);\n    newTemplate.raw.push(result.transformed);\n    runningContext = result.runningContext;\n    if (i < template.raw.length - 1) {\n      const substitution = substitutions[i];\n      if (substitution instanceof Pattern) {\n        const result = preprocessor(substitution, {...runningContext, lastPos: 0}, options);\n        newSubstitutions.push(pattern(result.transformed));\n        runningContext = result.runningContext;\n      } else {\n        newSubstitutions.push(substitution);\n      }\n    }\n  });\n  return {\n    template: newTemplate,\n    substitutions: newSubstitutions,\n  };\n}\n\n// Sandbox `^` if relevant, done so it can't change the meaning of the surrounding character class\n// if we happen to be at the first position. See `sandboxLoneDoublePunctuatorChar` for more details\nfunction sandboxLoneCharClassCaret(str) {\n  return str.replace(/^\\^/, '\\\\^^');\n}\n\n// Sandbox without escaping by repeating the character and escaping only the first one. The second\n// one is so that, if followed by the same symbol, the resulting double punctuator will still throw\n// as expected. Details:\n// - Only need to check the first position because, if it's part of an implicit union,\n//   interpolation handling will wrap it in nested `[\u2026]`.\n// - Can't just wrap in nested `[\u2026]` here, since the value might be used in a range.\n// - Can't add a second unescaped symbol if a lone symbol is the entire string because it might be\n//   followed by the same unescaped symbol outside an interpolation, and since it won't be wrapped,\n//   the second symbol wouldn't be sandboxed from the one following it.\nfunction sandboxLoneDoublePunctuatorChar(str) {\n  return str.replace(new RegExp(`^([${doublePunctuatorChars}])(?!\\\\1)`), (m, _, pos) => {\n    return `\\\\${m}${pos + 1 === str.length ? '' : m}`;\n  });\n}\n\n/**\nConverts `\\0` tokens to `\\x00` in the given context.\n@param {string} str\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] `Context` option from lib `regex-utilities`\n@returns {string}\n*/\nfunction sandboxUnsafeNulls(str, context) {\n  // regex`[\\0${0}]` and regex`[${pattern`\\0`}0]` can't be guarded against via nested `[\u2026]`\n  // sandboxing in character classes if the interpolated value doesn't contain union (since it\n  // might be placed on a range boundary). So escape `\\0` in character classes as `\\x00`\n  return replaceUnescaped(str, String.raw`\\\\0(?!\\d)`, '\\\\x00', context);\n}\n\nexport {\n  adjustNumberedBackrefs,\n  capturingDelim,\n  CharClassContext,\n  containsCharClassUnion,\n  countCaptures,\n  doublePunctuatorChars,\n  enclosedTokenCharClassContexts,\n  enclosedTokenRegexContexts,\n  envSupportsFlagGroups,\n  envSupportsFlagV,\n  escapeV,\n  getBreakoutChar,\n  getEndContextForIncompleteExpression,\n  namedCapturingDelim,\n  preprocess,\n  RegexContext,\n  sandboxLoneCharClassCaret,\n  sandboxLoneDoublePunctuatorChar,\n  sandboxUnsafeNulls,\n};\n", "import {doublePunctuatorChars} from './utils.js';\n/**\n@import {PluginResult} from './regex.js';\n*/\n\nconst incompatibleEscapeChars = '&!#%,:;<=>@`~';\nconst token = new RegExp(String.raw`\n\\[\\^?-?\n| --?\\]\n| (?<dp>[${doublePunctuatorChars}])\\k<dp>\n| --\n| \\\\(?<vOnlyEscape>[${incompatibleEscapeChars}])\n| \\\\[pPu]\\{[^}]+\\}\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nApplies flag v rules when using flag u, for forward compatibility.\nAssumes flag u and doesn't worry about syntax errors that are caught by it.\n@param {string} expression\n@returns {PluginResult}\n*/\nfunction backcompatPlugin(expression) {\n  const unescapedLiteralHyphenMsg = 'Invalid unescaped \"-\" in character class';\n  let inCharClass = false;\n  let result = '';\n  for (const {0: m, groups: {dp, vOnlyEscape}} of expression.matchAll(token)) {\n    if (m[0] === '[') {\n      if (inCharClass) {\n        throw new Error('Invalid nested character class when flag v not supported; possibly from interpolation');\n      }\n      if (m.endsWith('-')) {\n        throw new Error(unescapedLiteralHyphenMsg);\n      }\n      inCharClass = true;\n    } else if (m.endsWith(']')) {\n      if (m[0] === '-') {\n        throw new Error(unescapedLiteralHyphenMsg);\n      }\n      inCharClass = false;\n    } else if (inCharClass) {\n      if (m === '&&' || m === '--') {\n        throw new Error(`Invalid set operator \"${m}\" when flag v not supported`);\n      } else if (dp) {\n        throw new Error(`Invalid double punctuator \"${m}\", reserved by flag v`);\n      } else if ('(){}/|'.includes(m)) {\n        throw new Error(`Invalid unescaped \"${m}\" in character class`);\n      } else if (vOnlyEscape) {\n        // Remove the escaping backslash to emulate flag v rules, since this character is allowed\n        // to be escaped within character classes with flag v but not with flag u\n        result += vOnlyEscape;\n        continue;\n      }\n    }\n    result += m;\n  }\n  return {\n    pattern: result,\n  };\n}\n\nexport {\n  backcompatPlugin,\n};\n", "import {getEndContextForIncompleteExpression, RegexContext} from './utils.js';\nimport {noncapturingDelim} from './utils-internals.js';\n/**\n@import {Preprocessor} from './utils.js';\n*/\n\nconst token = new RegExp(String.raw`\n${noncapturingDelim}\n| \\(\\?<\n| (?<backrefNum>\\\\[1-9]\\d*)\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nApply transformations for flag n (named capture only).\n\nPreprocessors are applied to the outer regex and interpolated patterns, but not interpolated\nregexes or strings.\n@type {Preprocessor}\n*/\nfunction flagNPreprocessor(value, runningContext) {\n  value = String(value);\n  let expression = '';\n  let transformed = '';\n  for (const {0: m, groups: {backrefNum}} of value.matchAll(token)) {\n    expression += m;\n    runningContext = getEndContextForIncompleteExpression(expression, runningContext);\n    const {regexContext} = runningContext;\n    if (regexContext === RegexContext.DEFAULT) {\n      if (m === '(') {\n        transformed += '(?:';\n      } else if (backrefNum) {\n        throw new Error(`Invalid decimal escape \"${m}\" with implicit flag n; replace with named backreference`);\n      } else {\n        transformed += m;\n      }\n    } else {\n      transformed += m;\n    }\n  }\n  return {\n    transformed,\n    runningContext,\n  };\n}\n\nexport {\n  flagNPreprocessor,\n};\n", "import {CharClassContext, doublePunctuatorChars, getEndContextForIncompleteExpression, RegexContext, sandboxLoneDoublePunctuatorChar, sandboxUnsafeNulls} from './utils.js';\nimport {noncapturingDelim} from './utils-internals.js';\nimport {Context, replaceUnescaped} from 'regex-utilities';\n/**\n@import {PluginResult} from './regex.js';\n@import {Preprocessor} from './utils.js';\n*/\n\nconst ws = /^\\s$/;\nconst escapedWsOrHash = /^\\\\[\\s#]$/;\nconst charClassWs = /^[ \\t]$/;\nconst escapedCharClassWs = /^\\\\[ \\t]$/;\nconst token = new RegExp(String.raw`\n\\\\(?: [gk]<\n  | [pPu]\\{\n  | c[A-Za-z]\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  | 0\\d+\n)\n| \\[\\^\n| ${noncapturingDelim}\n| \\(\\?<\n| (?<dp>[${doublePunctuatorChars}])\\k<dp>\n| --\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nApply transformations for flag x (insignificant whitespace and line comments).\n\nPreprocessors are applied to the outer regex and interpolated patterns, but not interpolated\nregexes or strings.\n@type {Preprocessor}\n*/\nfunction flagXPreprocessor(value, runningContext, options) {\n  value = String(value);\n  let ignoringWs = false;\n  let ignoringCharClassWs = false;\n  let ignoringComment = false;\n  let expression = '';\n  let transformed = '';\n  let lastSignificantToken = '';\n  let lastSignificantCharClassContext = '';\n  let separatorNeeded = false;\n  const update = (str, options) => {\n    const opts = {\n      prefix: true,\n      postfix: false,\n      ...options,\n    };\n    str = (separatorNeeded && opts.prefix ? '(?:)' : '') + str + (opts.postfix ? '(?:)' : '');\n    separatorNeeded = false;\n    return str;\n  };\n  for (const {0: m, index} of value.matchAll(token)) {\n    if (ignoringComment) {\n      if (m === '\\n') {\n        ignoringComment = false;\n        separatorNeeded = true;\n      }\n      continue;\n    }\n    if (ignoringWs) {\n      if (ws.test(m)) {\n        continue;\n      }\n      ignoringWs = false;\n      separatorNeeded = true;\n    } else if (ignoringCharClassWs) {\n      if (charClassWs.test(m)) {\n        continue;\n      }\n      ignoringCharClassWs = false;\n    }\n\n    expression += m;\n    runningContext = getEndContextForIncompleteExpression(expression, runningContext);\n    const {regexContext, charClassContext} = runningContext;\n    if (\n      // `--` is matched in one step, so boundary chars aren't `-` unless separated by whitespace\n      m === '-' &&\n      regexContext === RegexContext.CHAR_CLASS &&\n      lastSignificantCharClassContext === CharClassContext.RANGE &&\n      (options.flags.includes('v') || options.unicodeSetsPlugin)\n    ) {\n      // Need to handle this here since the main regex-parsing code would think the hyphen forms\n      // part of a subtraction operator since we've removed preceding whitespace\n      throw new Error('Invalid unescaped hyphen as the end value for a range');\n    }\n    if (\n      // `??` is matched in one step by the double punctuator token\n      (regexContext === RegexContext.DEFAULT && /^(?:[?*+]|\\?\\?)$/.test(m)) ||\n      (regexContext === RegexContext.INTERVAL_QUANTIFIER && m === '{')\n    ) {\n      // Skip the separator prefix and connect the quantifier to the previous token. This also\n      // allows whitespace between a quantifier and the `?` that makes it lazy. Add a postfix\n      // separator if `m` is `?` and we're following token `(`, to sandbox the `?` from following\n      // tokens (since `?` can be a group-type marker). Ex: `( ?:)` becomes `(?(?:):)` and throws.\n      // The loop we're in matches valid group openings in one step, so we won't arrive here if\n      // matching e.g. `(?:`. Flag n could prevent the need for the postfix since bare `(` is\n      // converted to `(?:`, but flag x handling always comes first and flag n can be turned off\n      transformed += update(m, {prefix: false, postfix: lastSignificantToken === '(' && m === '?'});\n    } else if (regexContext === RegexContext.DEFAULT) {\n      if (ws.test(m)) {\n        ignoringWs = true;\n      } else if (m.startsWith('#')) {\n        ignoringComment = true;\n      } else if (escapedWsOrHash.test(m)) {\n        transformed += update(m[1], {prefix: false});\n      } else {\n        transformed += update(m);\n      }\n    } else if (regexContext === RegexContext.CHAR_CLASS && m !== '[' && m !== '[^') {\n      if (\n        charClassWs.test(m) &&\n        ( charClassContext === CharClassContext.DEFAULT ||\n          charClassContext === CharClassContext.ENCLOSED_Q ||\n          charClassContext === CharClassContext.RANGE\n        )\n      ) {\n        ignoringCharClassWs = true;\n      } else if (charClassContext === CharClassContext.INVALID_INCOMPLETE_TOKEN) {\n        // Need to handle this here since the main regex-parsing code wouldn't know where the token\n        // ends if we removed whitespace after an incomplete token that is followed by something\n        // that completes the token\n        throw new Error(`Invalid incomplete token in character class: \"${m}\"`);\n      } else if (\n        escapedCharClassWs.test(m) &&\n        (charClassContext === CharClassContext.DEFAULT || charClassContext === CharClassContext.ENCLOSED_Q)\n      ) {\n        transformed += update(m[1], {prefix: false});\n      } else if (charClassContext === CharClassContext.DEFAULT) {\n        const nextChar = value[index + 1] ?? '';\n        let updated = sandboxUnsafeNulls(m);\n        // Avoid escaping lone double punctuators unless required, since some of them are not\n        // allowed to be escaped with flag u (the `unicodeSetsPlugin` already unescapes them when\n        // using flag u, but it can be set to `null` via an option)\n        if (charClassWs.test(nextChar) || m === '^') {\n          updated = sandboxLoneDoublePunctuatorChar(updated);\n        }\n        transformed += update(updated);\n      } else {\n        transformed += update(m);\n      }\n    } else {\n      transformed += update(m);\n    }\n    if (!(ignoringWs || ignoringCharClassWs || ignoringComment)) {\n      lastSignificantToken = m;\n      lastSignificantCharClassContext = charClassContext;\n    }\n  }\n  return {\n    transformed,\n    runningContext,\n  };\n}\n\n/**\nRemove `(?:)` token separators (most likely added by flag x) in cases where it's safe to do so.\n@param {string} expression\n@returns {PluginResult}\n*/\nfunction clean(expression) {\n  const sep = String.raw`\\(\\?:\\)`;\n  // No need for repeated separators\n  expression = replaceUnescaped(expression, `(?:${sep}){2,}`, '(?:)', Context.DEFAULT);\n  // No need for separators at:\n  // - The beginning, if not followed by a quantifier.\n  // - The end.\n  // - Outside of character classes:\n  //   - If followed by one of `)|.[$\\\\`, or `(` if that's not followed by `DEFINE)`.\n  //     - Technically we shouldn't remove `(?:)` if preceded by `(?(DEFINE` and followed by `)`,\n  //       but in this case flag x injects a sandboxing `(?:)` after the preceding invalid `(?`,\n  //       so we already get an error from that.\n  //   - If preceded by one of `()|.]^>`, `\\\\[bBdDfnrsStvwW]`, `(?:`, or a lookaround opening.\n  //     - So long as the separator is not followed by a quantifier.\n  // Examples of things that are not safe to remove `(?:)` at the boundaries of:\n  // - Anywhere: Letters, numbers, or any of `-=_,<?*+{}`.\n  // - If followed by any of `:!>`.\n  // - If preceded by any of `\\\\[cgkpPux]`.\n  // - Anything inside character classes.\n  expression = replaceUnescaped(\n    expression,\n    String.raw`${sep}(?=[)|.[$\\\\]|\\((?!DEFINE)|$)|(?<=[()|.\\]^>]|\\\\[bBdDfnrsStvwW]|\\(\\?(?:[:=!]|<[=!])|^)${sep}(?![?*+{])`,\n    '',\n    Context.DEFAULT\n  );\n  return {\n    pattern: expression,\n  };\n}\n\nexport {\n  clean,\n  flagXPreprocessor,\n};\n", "/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but automatically\nadjusts subpattern matches and indices (with flag `d`) to account for captures added as part of\nemulating extended syntax.\n*/\nclass RegExpSubclass extends RegExp {\n  // Avoid `#private` to allow for subclassing\n  /**\n  @private\n  @type {Map<number, {\n    hidden: true;\n  }>}\n  */\n  _captureMap;\n  /**\n  @overload\n  @param {string} expression\n  @param {string} [flags]\n  @param {{\n    hiddenCaptures?: Array<number>;\n  }} [options]\n  */\n  /**\n  @overload\n  @param {RegExpSubclass} expression\n  @param {string} [flags]\n  */\n  constructor(expression, flags, options) {\n    // Argument `options` isn't provided when regexes are copied via `new RegExpSubclass(regexp)`,\n    // including as part of the internal handling of string methods `matchAll` and `split`\n    if (expression instanceof RegExp) {\n      if (options) {\n        throw new Error('Cannot provide options when copying a regexp');\n      }\n      super(expression, flags);\n      if (expression instanceof RegExpSubclass) {\n        this._captureMap = expression._captureMap;\n      } else {\n        this._captureMap = new Map();\n      }\n    } else {\n      super(expression, flags);\n      const hiddenCaptures = options?.hiddenCaptures ?? [];\n      this._captureMap = createCaptureMap(hiddenCaptures);\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const match = super.exec(str);\n    if (!match || !this._captureMap.size) {\n      return match;\n    }\n    const matchCopy = [...match];\n    // Empty all but the first value of the array while preserving its other properties\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    for (let i = 1; i < matchCopy.length; i++) {\n      if (!this._captureMap.get(i)?.hidden) {\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n    }\n    return match;\n  }\n}\n\n/**\nBuild the capturing group map, with hidden captures marked to indicate their submatches shouldn't\nappear in match results.\n@param {Array<number>} hiddenCaptures\n@returns {Map<number, {\n  hidden: true;\n}>}\n*/\nfunction createCaptureMap(hiddenCaptures) {\n  const captureMap = new Map();\n  for (const num of hiddenCaptures) {\n    captureMap.set(num, {\n      hidden: true,\n    });\n  }\n  return captureMap;\n}\n\nexport {\n  RegExpSubclass,\n};\n", "import {capturingDelim, countCaptures, namedCapturingDelim} from './utils.js';\nimport {incrementIfAtLeast, spliceStr} from './utils-internals.js';\nimport {Context, execUnescaped, forEachUnescaped, getGroupContents, hasUnescaped, replaceUnescaped} from 'regex-utilities';\n/**\n@import {PluginData, PluginResult} from './regex.js';\n*/\n\n/**\n@param {string} expression\n@param {PluginData} [data]\n@returns {PluginResult}\n*/\nfunction subroutines(expression, data) {\n  // NOTE: subroutines and definition groups fully support numbered backreferences and unnamed\n  // captures (from interpolated regexes or from turning implicit flag n off), and all of the\n  // complex forward and backward backreference adjustments that can result\n  const namedGroups = getNamedCapturingGroups(expression, {includeContents: true});\n  const transformed = processSubroutines(expression, namedGroups, data?.hiddenCaptures ?? []);\n  return {\n    pattern: processDefinitionGroup(transformed.pattern, namedGroups),\n    hiddenCaptures: transformed.hiddenCaptures,\n  };\n}\n\n// Explicitly exclude `&` from subroutine name chars because it's used by extension\n// `regex-recursion` for recursive subroutines via `\\g<name&R=N>`\nconst subroutinePattern = String.raw`\\\\g<(?<subroutineName>[^>&]+)>`;\nconst token = new RegExp(String.raw`\n${subroutinePattern}\n| (?<capturingStart>${capturingDelim})\n| \\\\(?<backrefNum>[1-9]\\d*)\n| \\\\k<(?<backrefName>[^>]+)>\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\n@typedef {\n  Map<string, {\n    isUnique: boolean;\n    contents?: string;\n    groupNum?: number;\n    numCaptures?: number;\n  }>} NamedCapturingGroupsMap\n*/\n/**\nApply transformations for subroutines: `\\g<name>`.\n@param {string} expression\n@param {NamedCapturingGroupsMap} namedGroups\n@param {Array<number>} hiddenCaptures\n@returns {PluginResult}\n*/\nfunction processSubroutines(expression, namedGroups, hiddenCaptures) {\n  if (!/\\\\g</.test(expression)) {\n    return {\n      pattern: expression,\n      hiddenCaptures,\n    };\n  }\n\n  // Can skip a lot of processing and avoid adding captures if there are no backrefs\n  const hasBackrefs = hasUnescaped(expression, '\\\\\\\\(?:[1-9]|k<[^>]+>)', Context.DEFAULT);\n  const subroutineWrapper = hasBackrefs ? '(' : '(?:';\n  const openSubroutines = new Map();\n  const openSubroutinesStack = [];\n  const captureNumMap = [0];\n  const addedHiddenCaptures = [];\n  let numCapturesPassedOutsideSubroutines = 0;\n  let numCapturesPassedInsideSubroutines = 0;\n  let numCapturesPassedInsideThisSubroutine = 0;\n  let numSubroutineCapturesTrackedInRemap = 0;\n  let numCharClassesOpen = 0;\n  let match;\n  token.lastIndex = 0;\n  while (match = token.exec(expression)) {\n    const {0: m, index, groups: {subroutineName, capturingStart, backrefNum, backrefName}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      if (subroutineName) {\n        if (!namedGroups.has(subroutineName)) {\n          throw new Error(`Invalid named capture referenced by subroutine ${m}`);\n        }\n        if (openSubroutines.has(subroutineName)) {\n          throw new Error(`Subroutine ${m} followed a recursive reference`);\n        }\n        const contents = namedGroups.get(subroutineName).contents;\n        // Wrap value in case it has top-level alternation or is followed by a quantifier. The\n        // wrapper also marks the end of the expanded contents, which we'll track using\n        // `unclosedGroupCount`. If there are any backrefs in the expression, wrap with `()`\n        // instead of `(?:)` in case there are backrefs inside the subroutine that refer to their\n        // containing capturing group\n        const subroutineValue = `${subroutineWrapper}${contents})`;\n        if (hasBackrefs) {\n          numCapturesPassedInsideThisSubroutine = 0;\n          numCapturesPassedInsideSubroutines++;\n          updateHiddenCaptureTracking(\n            hiddenCaptures,\n            addedHiddenCaptures,\n            numCapturesPassedOutsideSubroutines + numCapturesPassedInsideSubroutines\n          );\n        }\n        openSubroutines.set(subroutineName, {\n          // Incrementally decremented to track when we've left the group\n          unclosedGroupCount: countOpenParens(subroutineValue),\n        });\n        openSubroutinesStack.push(subroutineName);\n        // Expand the subroutine's contents into the pattern we're looping over\n        expression = spliceStr(expression, index, m, subroutineValue);\n        token.lastIndex -= m.length - subroutineWrapper.length;\n      } else if (capturingStart) {\n        // Somewhere within an expanded subroutine\n        if (openSubroutines.size) {\n          if (hasBackrefs) {\n            numCapturesPassedInsideThisSubroutine++;\n            numCapturesPassedInsideSubroutines++;\n            updateHiddenCaptureTracking(\n              hiddenCaptures,\n              addedHiddenCaptures,\n              numCapturesPassedOutsideSubroutines + numCapturesPassedInsideSubroutines\n            );\n          }\n          // Named capturing group\n          if (m !== '(') {\n            // Replace named with unnamed capture. Subroutines ideally wouldn't create any new\n            // captures, but it can't be helped since we need any backrefs to this capture to work.\n            // Given that flag n prevents unnamed capture and thereby requires you to rely on named\n            // backrefs and `groups`, switching to unnamed essentially accomplishes not creating a\n            // capture. Can fully avoid capturing if there are no backrefs in the expression\n            expression = spliceStr(expression, index, m, subroutineWrapper);\n            token.lastIndex -= m.length - subroutineWrapper.length;\n          }\n        } else if (hasBackrefs) {\n          captureNumMap.push(\n            lastOf(captureNumMap) + 1 +\n            numCapturesPassedInsideSubroutines -\n            numSubroutineCapturesTrackedInRemap\n          );\n          numSubroutineCapturesTrackedInRemap = numCapturesPassedInsideSubroutines;\n          numCapturesPassedOutsideSubroutines++;\n        }\n      } else if ((backrefNum || backrefName) && openSubroutines.size) {\n        // Unify handling for named and unnamed by always using the backref num\n        const num = backrefNum ? +backrefNum : namedGroups.get(backrefName)?.groupNum;\n        let isGroupFromThisSubroutine = false;\n        // Search for the group in the contents of the subroutine stack\n        for (const s of openSubroutinesStack) {\n          const group = namedGroups.get(s);\n          if (num >= group.groupNum && num <= (group.groupNum + group.numCaptures)) {\n            isGroupFromThisSubroutine = true;\n            break;\n          }\n        }\n        if (isGroupFromThisSubroutine) {\n          const group = namedGroups.get(lastOf(openSubroutinesStack));\n          // Replace the backref with metadata we'll need to rewrite it later, using\n          // `\\k<$$bNsNrNcN>` as a temporary wrapper:\n          // - b: The unmodified matched backref num, or the corresponding num of a named backref\n          // - s: The capture num of the subroutine we're most deeply nested in, including captures\n          //      added by expanding the contents of preceding subroutines\n          // - r: The original capture num of the group that the subroutine we're most deeply\n          //      nested in references, not counting the effects of subroutines\n          // - c: The number of captures within `r`, not counting the effects of subroutines\n          const subroutineNum = numCapturesPassedOutsideSubroutines + numCapturesPassedInsideSubroutines - numCapturesPassedInsideThisSubroutine;\n          const metadata = `\\\\k<$$b${num}s${subroutineNum}r${group.groupNum}c${group.numCaptures}>`;\n          expression = spliceStr(expression, index, m, metadata);\n          token.lastIndex += metadata.length - m.length;\n        }\n      } else if (m === ')') {\n        if (openSubroutines.size) {\n          const subroutine = openSubroutines.get(lastOf(openSubroutinesStack));\n          subroutine.unclosedGroupCount--;\n          if (!subroutine.unclosedGroupCount) {\n            openSubroutines.delete(openSubroutinesStack.pop());\n          }\n        }\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  hiddenCaptures.push(...addedHiddenCaptures);\n\n  if (hasBackrefs) {\n    // Second pass to adjust backrefs\n    expression = replaceUnescaped(\n      expression,\n      String.raw`\\\\(?:(?<bNum>[1-9]\\d*)|k<\\$\\$b(?<bNumSub>\\d+)s(?<subNum>\\d+)r(?<refNum>\\d+)c(?<refCaps>\\d+)>)`,\n      ({0: m, groups: {bNum, bNumSub, subNum, refNum, refCaps}}) => {\n        if (bNum) {\n          const backrefNum = +bNum;\n          if (backrefNum > captureNumMap.length - 1) {\n            throw new Error(`Backref \"${m}\" greater than number of captures`);\n          }\n          return `\\\\${captureNumMap[backrefNum]}`;\n        }\n        const backrefNumInSubroutine = +bNumSub;\n        const subroutineGroupNum = +subNum;\n        const refGroupNum = +refNum;\n        const numCapturesInRef = +refCaps;\n        if (backrefNumInSubroutine < refGroupNum || backrefNumInSubroutine > (refGroupNum + numCapturesInRef)) {\n          return `\\\\${captureNumMap[backrefNumInSubroutine]}`;\n        }\n        return `\\\\${subroutineGroupNum - refGroupNum + backrefNumInSubroutine}`;\n      },\n      Context.DEFAULT\n    );\n  }\n\n  return {\n    pattern: expression,\n    hiddenCaptures,\n  };\n}\n\n// `(?:)` allowed because it can be added by flag x's preprocessing of whitespace and comments\nconst defineGroupToken = new RegExp(String.raw`${namedCapturingDelim}|\\(\\?:\\)|(?<invalid>\\\\?.)`, 'gsu');\n\n/**\nRemove valid subroutine definition groups: `(?(DEFINE)\u2026)`.\n@param {string} expression\n@param {NamedCapturingGroupsMap} namedGroups\nIMPORTANT: Avoid using the `contents` property of `namedGroups` objects, because at this point\nsubroutine substitution has been performed on the corresponding substrings in `expression`\n@returns {string}\n*/\nfunction processDefinitionGroup(expression, namedGroups) {\n  const defineMatch = execUnescaped(expression, String.raw`\\(\\?\\(DEFINE\\)`, 0, Context.DEFAULT);\n  if (!defineMatch) {\n    return expression;\n  }\n  const defineGroup = getGroup(expression, defineMatch);\n  if (defineGroup.afterPos < expression.length) {\n    // Supporting DEFINE at positions other than the end would complicate backref handling.\n    // NOTE: Flag x's preprocessing permits trailing whitespace and comments\n    throw new Error('DEFINE group allowed only at the end of a regex');\n  } else if (defineGroup.afterPos > expression.length) {\n    throw new Error('DEFINE group is unclosed');\n  }\n  let match;\n  defineGroupToken.lastIndex = 0;\n  while (match = defineGroupToken.exec(defineGroup.contents)) {\n    const {captureName, invalid} = match.groups;\n    if (captureName) {\n      const group = getGroup(defineGroup.contents, match);\n      let duplicateName;\n      if (!namedGroups.get(captureName).isUnique) {\n        duplicateName = captureName;\n      } else {\n        const nestedNamedGroups = getNamedCapturingGroups(group.contents, {includeContents: false});\n        for (const name of nestedNamedGroups.keys()) {\n          if (!namedGroups.get(name).isUnique) {\n            duplicateName = name;\n            break;\n          }\n        }\n      }\n      if (duplicateName) {\n        throw new Error(`Duplicate group name \"${duplicateName}\" within DEFINE`);\n      }\n      defineGroupToken.lastIndex = group.afterPos;\n    } else if (invalid) {\n      // Since a DEFINE group is stripped from its expression, we can't easily determine whether\n      // unreferenced top-level syntax within it is valid. Such syntax serves no purpose, so it's\n      // easiest to not allow it\n      throw new Error(`DEFINE group includes unsupported syntax at top level`);\n    }\n  }\n  return expression.slice(0, defineMatch.index);\n}\n\n/**\nCounts unescaped open parens outside of character classes, regardless of group type\n@param {string} expression\n@returns {number}\n*/\nfunction countOpenParens(expression) {\n  let num = 0;\n  forEachUnescaped(expression, '\\\\(', () => num++, Context.DEFAULT);\n  return num;\n}\n\n/**\n@param {string} expression\n@param {string} groupName\n@returns {number}\n*/\nfunction getCaptureNum(expression, groupName) {\n  let num = 0;\n  let pos = 0;\n  let match;\n  while (match = execUnescaped(expression, capturingDelim, pos, Context.DEFAULT)) {\n    const {0: m, index, groups: {captureName}} = match;\n    num++;\n    if (captureName === groupName) {\n      break;\n    }\n    pos = index + m.length;\n  }\n  return num;\n}\n\n/**\n@param {string} expression\n@param {RegExpExecArray} delimMatch\n@returns {{contents: string; afterPos: number}}\n*/\nfunction getGroup(expression, delimMatch) {\n  const contentsStart = delimMatch.index + delimMatch[0].length;\n  const contents = getGroupContents(expression, contentsStart);\n  const afterPos = contentsStart + contents.length + 1;\n  return {\n    contents,\n    afterPos,\n  };\n}\n\n/**\n@param {string} expression\n@param {{includeContents: boolean}} options\n@returns {NamedCapturingGroupsMap}\n*/\nfunction getNamedCapturingGroups(expression, {includeContents}) {\n  const namedGroups = new Map();\n  forEachUnescaped(\n    expression,\n    namedCapturingDelim,\n    ({0: m, index, groups: {captureName}}) => {\n      // If there are duplicate capture names, subroutines refer to the first instance of the given\n      // group (matching the behavior of PCRE and Perl)\n      if (namedGroups.has(captureName)) {\n        namedGroups.get(captureName).isUnique = false;\n      } else {\n        const group = {isUnique: true};\n        if (includeContents) {\n          const contents = getGroupContents(expression, index + m.length);\n          Object.assign(group, {\n            contents,\n            groupNum: getCaptureNum(expression, captureName),\n            numCaptures: countCaptures(contents),\n          });\n        }\n        namedGroups.set(captureName, group);\n      }\n    },\n    Context.DEFAULT\n  );\n  return namedGroups;\n}\n\n/**\n@param {Array<any>} arr\n@returns {any}\n*/\nfunction lastOf(arr) {\n  // Remove when support for ES2022 array method `at` (Node.js 16.6) is no longer an issue:\n  // <https://caniuse.com/mdn-javascript_builtins_array_at>\n  return arr[arr.length - 1];\n}\n\n/**\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} addedCaptureNum\n*/\nfunction updateHiddenCaptureTracking(hiddenCaptures, addedHiddenCaptures, addedCaptureNum) {\n  addedHiddenCaptures.push(addedCaptureNum);\n  incrementIfAtLeast(hiddenCaptures, addedCaptureNum);\n}\n\nexport {\n  subroutines,\n};\n"],
  "mappings": "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",
  "names": ["token", "result", "token", "token", "options", "token"]
}
