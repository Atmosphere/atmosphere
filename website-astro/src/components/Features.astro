---
const features = [
  {
    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z"/>
      <path d="m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z"/>
      <path d="M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0"/>
      <path d="M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5"/>
    </svg>`,
    title: 'Virtual Threads',
    description: 'Every connection runs on a JDK 21 virtual thread. Massive scalability with no thread-pool tuning.',
    detail: `<p>Atmosphere 4.0 assigns a <strong>JDK 21 virtual thread</strong> to every connection. Virtual threads are lightweight — the JVM can schedule millions of them without the memory overhead of platform threads.</p>
<p>This fundamentally changes the programming model. Your message handlers can make <strong>blocking calls</strong> — database queries, REST APIs, LLM inference — and the JVM transparently parks the virtual thread until the I/O completes. No thread-pool tuning, no async callback chains, no reactive wrappers.</p>
<div class="detail-stats">
  <div class="detail-stat"><span class="detail-stat-value">~1 KB</span><span class="detail-stat-label">memory per virtual thread</span></div>
  <div class="detail-stat"><span class="detail-stat-value">1M+</span><span class="detail-stat-label">concurrent connections</span></div>
  <div class="detail-stat"><span class="detail-stat-value">0</span><span class="detail-stat-label">thread-pool config needed</span></div>
</div>
<p><strong>Before (2.x):</strong> Platform threads consumed ~1 MB each. A 200-thread pool capped you at 200 concurrent connections. Scaling required careful tuning, async handlers, and callback-driven I/O.</p>
<p><strong>Now (4.0):</strong> Write simple, synchronous code. The JVM handles the concurrency. Every handler runs on its own virtual thread — blocking is free.</p>`,
    wikiLink: 'https://github.com/Atmosphere/atmosphere/wiki',
  },
  {
    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/>
      <path d="m9 12 2 2 4-4"/>
    </svg>`,
    title: 'WebSocket + Fallbacks',
    description: 'First-class WebSocket with automatic degradation to SSE and long-polling. Heartbeats and reconnection built in.',
    detail: `<p>Atmosphere automatically negotiates the <strong>best available transport</strong> between client and server. It starts with WebSocket, and seamlessly falls back to Server-Sent Events (SSE), then long-polling if needed. Your application code is completely transport-agnostic.</p>
<p>The transport layer includes built-in resilience features that work transparently:</p>
<ul>
<li><strong>Heartbeat detection</strong> — configurable pings detect dead connections before TCP timeouts kick in, enabling fast cleanup and reconnection</li>
<li><strong>Automatic reconnection</strong> — exponential backoff with jitter prevents thundering-herd reconnects after a server restart</li>
<li><strong>Message cache</strong> — messages are cached server-side and replayed on reconnect, so clients never miss data during a brief disconnect</li>
<li><strong>Proxy-safe</strong> — long-polling and SSE work behind corporate proxies, CDNs, and load balancers that may not support WebSocket</li>
</ul>
<p>The protocol negotiation happens via an initial handshake request. The client advertises supported transports, the server picks the best match, and the connection upgrades transparently. If the primary transport fails mid-session, the client reconnects on the fallback without application-level intervention.</p>`,
    wikiLink: 'https://github.com/Atmosphere/atmosphere/wiki/Getting-Started-with-atmosphere.js',
  },
  {
    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
      <circle cx="9" cy="7" r="4"/>
      <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
      <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
    </svg>`,
    title: 'Rooms & Presence',
    description: 'Built-in room management with presence tracking, message history, and authorization. No external dependencies.',
    detail: `<p>Rooms are a <strong>first-class abstraction</strong> in Atmosphere 4.0 — a higher-level layer above Broadcasters that handles the most common real-time patterns: group messaging, user presence, and message history.</p>
<p>A Room is a named group of connections managed automatically by the framework. When a client connects, Atmosphere creates a <code>RoomMember</code> record (an immutable data object with an ID, metadata, and join timestamp) and fires a presence event to all existing members.</p>
<p><strong>What the Room manages for you:</strong></p>
<ul>
<li><strong>Presence tracking</strong> — real-time join/leave events, queryable member list. Presence events include metadata so clients can display user profiles, avatars, or roles</li>
<li><strong>Message history</strong> — a configurable in-memory cache (max items, TTL, per-client limits). New joiners automatically receive recent history on connect</li>
<li><strong>Direct messaging</strong> — send a message to a specific member by ID without broadcasting to the entire room</li>
<li><strong>Authorization</strong> — an optional callback lets you accept or reject join requests based on tokens, roles, or room capacity</li>
<li><strong>Virtual members</strong> — non-connection participants like AI agents or bots can join a room, receive messages, and respond — with their own presence events</li>
</ul>
<p>Rooms are exposed via a REST-style protocol over the WebSocket connection, with JSON-framed commands for <code>join</code>, <code>leave</code>, <code>message</code>, and <code>direct</code>. The <code>RoomProtocolInterceptor</code> parses these automatically.</p>`,
    wikiLink: 'https://github.com/Atmosphere/atmosphere/wiki/Understanding-Rooms',
  },
  {
    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="16 18 22 12 16 6"/>
      <polyline points="8 6 2 12 8 18"/>
    </svg>`,
    title: 'Simple Annotations',
    description: 'Define endpoints with @ManagedService or @RoomService. Handle lifecycle with @Ready, @Message, @Disconnect. Kotlin DSL available.',
    detail: `<p>Atmosphere 4.0 is annotation-driven. Two annotations cover the vast majority of real-time use cases, and lifecycle hooks handle the rest.</p>
<div class="detail-columns">
<div>
<h4>@ManagedService</h4>
<p>The general-purpose annotation. Maps a URL path to a class, auto-creates a Broadcaster, and dispatches lifecycle events. Best for pub/sub, notifications, dashboards, and any pattern where you control the broadcast logic directly.</p>
</div>
<div>
<h4>@RoomService</h4>
<p>A room-aware annotation that auto-creates Room instances with presence tracking, member management, and message history. Best for chat, collaboration, multiplayer, and any grouped communication pattern.</p>
</div>
</div>
<p><strong>Lifecycle hooks</strong> are shared across both annotations:</p>
<ul>
<li><strong>@Ready</strong> — client connection established (inject <code>AtmosphereResource</code> or <code>Room</code>)</li>
<li><strong>@Message</strong> — message received, with optional JSON encoding/decoding via <code>encoders</code> and <code>decoders</code> attributes</li>
<li><strong>@Disconnect</strong> — client disconnected or timed out</li>
<li><strong>@Heartbeat</strong> — heartbeat received from the client</li>
</ul>
<p>For Kotlin projects, a <strong>type-safe DSL</strong> provides the same capabilities in a functional style, with coroutine-aware suspend extensions for non-blocking broadcast and write operations. Both approaches are fully supported under Spring Boot and Quarkus.</p>`,
    wikiLink: 'https://github.com/Atmosphere/atmosphere/wiki/Understanding-ManagedService',
  },
  {
    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
      <polyline points="3.29 7 12 12 20.71 7"/>
      <line x1="12" y1="22" x2="12" y2="12"/>
    </svg>`,
    title: 'Kafka & Redis Clustering',
    description: 'Scale across nodes with built-in Kafka and Redis broadcasters. Open source, no commercial add-ons required.',
    detail: `<p>Atmosphere scales horizontally by <strong>replacing the broadcaster implementation</strong> — a single configuration change, zero code modifications. All <code>@ManagedService</code> and <code>@RoomService</code> endpoints continue working unmodified across a cluster.</p>
<div class="detail-columns">
<div>
<h4>Apache Kafka</h4>
<p>Built on <strong>Kafka 3.9</strong>. Each Broadcaster maps to a Kafka topic. Messages published on one node are consumed by all nodes and delivered to their local subscribers. Kafka's durability guarantees mean messages survive broker restarts.</p>
<p>Best for: high-throughput, ordered delivery, environments that already run Kafka.</p>
</div>
<div>
<h4>Redis Pub/Sub</h4>
<p>Built on <strong>Lettuce 6.5</strong> (non-blocking Redis client). Uses Redis Pub/Sub channels — each Broadcaster maps to a channel. Ultra-low latency fan-out across nodes with minimal infrastructure.</p>
<p>Best for: low-latency, simple deployments, ephemeral messaging where Kafka's durability isn't needed.</p>
</div>
</div>
<p><strong>Architecture:</strong> The clustering layer sits below the Broadcaster interface. When a message is broadcast, it is published to Kafka/Redis and simultaneously delivered to local subscribers. Remote nodes receive the message and deliver it to their local subscribers. The deduplication logic ensures each client receives the message exactly once.</p>
<p>Both modules are <strong>fully open source</strong> — no commercial add-ons or paid tiers.</p>`,
    wikiLink: 'https://github.com/Atmosphere/atmosphere/wiki/Clustering-Kafka-and-Redis',
  },
  {
    icon: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 2a4 4 0 0 0-4 4v2H6a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2h-2V6a4 4 0 0 0-4-4z"/>
      <circle cx="12" cy="15" r="2"/>
      <path d="M12 17v2"/>
    </svg>`,
    title: 'AI / LLM Streaming',
    description: 'Stream AI responses token-by-token over WebSocket. Built-in adapters for Spring AI, LangChain4j, and Embabel.',
    detail: `<p>Atmosphere provides a <strong>streaming SPI</strong> that delivers LLM responses token-by-token over the existing WebSocket connection. No separate HTTP streaming endpoint, no SSE workaround — tokens flow through the same real-time channel as your other messages.</p>
<p><strong>How it works:</strong> The <code>StreamingSession</code> abstraction writes JSON frames directly to the <code>AtmosphereResource</code>, bypassing the Broadcaster for minimal latency. Each frame carries a type (<code>token</code>, <code>progress</code>, <code>metadata</code>, <code>complete</code>, <code>error</code>), a sequence number, and a session ID — enabling the client to reconstruct the stream and handle multiplexed sessions.</p>
<p><strong>Built-in adapters</strong> bridge Atmosphere's streaming to popular AI frameworks:</p>
<ul>
<li><strong>Spring AI</strong> — wraps <code>Flux&lt;String&gt;</code> streams, subscribing to tokens and writing each to the session</li>
<li><strong>LangChain4j</strong> — implements the callback interface, forwarding each token event to the session</li>
<li><strong>Embabel</strong> — connects Kotlin coroutine <code>OutputChannel</code> to the session for agent-based workflows</li>
</ul>
<p>A built-in <strong>OpenAI-compatible HTTP client</strong> (JDK 21 <code>HttpClient</code>) works directly with OpenAI, Google Gemini, Azure OpenAI, and Ollama — no framework dependency required. It auto-detects the API endpoint from the model name.</p>
<p><strong>Virtual Room Members:</strong> Beyond streaming endpoints, you can add an LLM as a room participant. The <code>LlmRoomMember</code> joins a Room, receives every broadcasted message, and responds — making AI assistants that participate naturally in group conversations.</p>
<p>Client-side, <code>atmosphere.js</code> provides <code>useStreaming()</code> hooks for React, Vue, and Svelte that handle token accumulation, loading states, and error recovery.</p>`,
    wikiLink: 'https://github.com/Atmosphere/atmosphere/wiki/AI-LLM-Streaming',
  },
];
---

<section class="features" id="features">
  <div class="features-container">
    <div class="section-header">
      <span class="section-label">Capabilities</span>
      <h2 class="section-title">Everything you need for real-time</h2>
      <p class="section-description">
        A complete toolkit for building scalable, real-time applications on the JVM.
      </p>
    </div>

    <div class="features-grid">
      {features.map((feature, index) => (
        <article class="feature-card" data-feature={index} style={`--delay: ${index * 0.1}s`} role="button" tabindex="0" aria-haspopup="dialog">
          <div class="feature-icon" set:html={feature.icon} />
          <h3 class="feature-title">{feature.title}</h3>
          <p class="feature-description">{feature.description}</p>
          <span class="feature-expand-hint">Click to explore →</span>
        </article>
      ))}
    </div>
  </div>

  <!-- Modal overlay -->
  <div class="feature-modal-overlay" id="featureModal" aria-hidden="true">
    <div class="feature-modal" role="dialog" aria-modal="true">
      <button class="feature-modal-close" aria-label="Close">&times;</button>
      <div class="feature-modal-header">
        <div class="feature-modal-icon" id="modalIcon"></div>
        <h3 class="feature-modal-title" id="modalTitle"></h3>
      </div>
      <div class="feature-modal-body" id="modalBody"></div>
      <div class="feature-modal-footer">
        <a class="feature-modal-link" id="modalLink" href="#" target="_blank" rel="noopener">
          Read the full guide →
        </a>
      </div>
    </div>
  </div>
</section>

<script define:vars={{ features }}>
  document.addEventListener('DOMContentLoaded', () => {
    const overlay = document.getElementById('featureModal');
    const modalIcon = document.getElementById('modalIcon');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    const modalLink = document.getElementById('modalLink');
    const closeBtn = overlay.querySelector('.feature-modal-close');

    function openModal(index) {
      const f = features[index];
      modalIcon.innerHTML = f.icon;
      modalTitle.textContent = f.title;
      modalBody.innerHTML = f.detail;
      modalLink.href = f.wikiLink;
      overlay.setAttribute('aria-hidden', 'false');
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden';
      closeBtn.focus();
    }

    function closeModal() {
      overlay.classList.remove('active');
      overlay.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
    }

    document.querySelectorAll('.feature-card[data-feature]').forEach(card => {
      card.addEventListener('click', () => openModal(Number(card.dataset.feature)));
      card.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openModal(Number(card.dataset.feature)); }
      });
    });

    closeBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });
  });
</script>

<style>
  .features {
    padding: var(--space-4xl) var(--space-xl);
    background: var(--color-bg-secondary);
    position: relative;
  }

  .features::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--color-border-accent), transparent);
  }

  .features-container {
    max-width: 1200px;
    margin: 0 auto;
  }

  .section-header {
    text-align: center;
    max-width: 600px;
    margin: 0 auto var(--space-3xl);
  }

  .section-label {
    display: inline-block;
    font-family: var(--font-mono);
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--color-accent);
    margin-bottom: var(--space-md);
  }

  .section-title {
    font-family: var(--font-display);
    font-size: clamp(2rem, 5vw, 2.75rem);
    font-weight: 400;
    line-height: 1.2;
    letter-spacing: -0.02em;
    margin-bottom: var(--space-md);
  }

  .section-description {
    font-size: 1.0625rem;
    color: var(--color-text-secondary);
    line-height: 1.6;
  }

  .features-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--space-lg);
  }

  .feature-card {
    padding: var(--space-xl);
    background: var(--color-bg-tertiary);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    transition: all 0.3s var(--ease-out-quad);
    animation: fadeInUp 0.6s var(--ease-out-expo) var(--delay) both;
    cursor: pointer;
    position: relative;
  }

  .feature-card:hover {
    border-color: var(--color-border-accent);
    transform: translateY(-4px);
    box-shadow: 0 20px 40px -20px rgba(0, 0, 0, 0.5);
  }

  .feature-card:focus-visible {
    outline: 2px solid var(--color-accent);
    outline-offset: 2px;
  }

  .feature-expand-hint {
    display: block;
    margin-top: var(--space-md);
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: var(--color-accent);
    opacity: 0;
    transform: translateX(-4px);
    transition: all 0.3s var(--ease-out-quad);
  }

  .feature-card:hover .feature-expand-hint {
    opacity: 1;
    transform: translateX(0);
  }

  .feature-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 48px;
    height: 48px;
    background: var(--color-accent-glow);
    border-radius: 10px;
    color: var(--color-accent);
    margin-bottom: var(--space-lg);
    transition: all 0.3s var(--ease-out-quad);
  }

  .feature-card:hover .feature-icon {
    background: var(--color-accent);
    color: var(--color-bg-primary);
  }

  .feature-title {
    font-family: var(--font-body);
    font-size: 1.125rem;
    font-weight: 600;
    margin-bottom: var(--space-sm);
  }

  .feature-description {
    font-size: 0.9375rem;
    color: var(--color-text-secondary);
    line-height: 1.6;
  }

  /* ── Modal ── */
  .feature-modal-overlay {
    position: fixed;
    inset: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0);
    backdrop-filter: blur(0);
    pointer-events: none;
    transition: background 0.35s ease, backdrop-filter 0.35s ease;
  }

  .feature-modal-overlay.active {
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(8px);
    pointer-events: auto;
  }

  .feature-modal {
    position: relative;
    width: min(720px, 92vw);
    max-height: 85vh;
    overflow-y: auto;
    background: var(--color-bg-tertiary);
    border: 1px solid var(--color-border-accent);
    border-radius: 16px;
    padding: var(--space-2xl);
    box-shadow: 0 40px 80px -20px rgba(0, 0, 0, 0.6);
    transform: translateY(24px) scale(0.96);
    opacity: 0;
    transition: transform 0.35s var(--ease-out-expo), opacity 0.3s ease;
  }

  .feature-modal-overlay.active .feature-modal {
    transform: translateY(0) scale(1);
    opacity: 1;
  }

  .feature-modal-close {
    position: absolute;
    top: var(--space-md);
    right: var(--space-md);
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    line-height: 1;
    color: var(--color-text-secondary);
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .feature-modal-close:hover {
    color: var(--color-text-primary);
    border-color: var(--color-border-accent);
    background: var(--color-bg-primary);
  }

  .feature-modal-header {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    margin-bottom: var(--space-xl);
    padding-right: var(--space-2xl);
  }

  .feature-modal-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    width: 48px;
    height: 48px;
    background: var(--color-accent);
    border-radius: 10px;
    color: var(--color-bg-primary);
  }

  .feature-modal-title {
    font-family: var(--font-display);
    font-size: 1.5rem;
    font-weight: 500;
    letter-spacing: -0.01em;
  }

  .feature-modal-body {
    font-size: 0.9375rem;
    line-height: 1.7;
    color: var(--color-text-secondary);
  }

  .feature-modal-body p {
    margin-bottom: var(--space-md);
  }

  .feature-modal-body strong {
    color: var(--color-text-primary);
  }

  .feature-modal-body code {
    font-family: var(--font-mono);
    font-size: 0.85em;
    background: var(--color-bg-primary);
    padding: 0.15em 0.4em;
    border-radius: 4px;
    color: var(--color-accent);
  }

  .feature-modal-body pre {
    background: var(--color-bg-primary);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: var(--space-md);
    margin-bottom: var(--space-md);
    overflow-x: auto;
  }

  .feature-modal-body pre code {
    background: none;
    padding: 0;
    font-size: 0.8125rem;
    line-height: 1.6;
    color: var(--color-text-primary);
  }

  .feature-modal-body ul {
    padding-left: 1.25em;
    margin-bottom: var(--space-md);
  }

  .feature-modal-body li {
    margin-bottom: 0.35em;
  }

  .feature-modal-body h4 {
    font-family: var(--font-body);
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--color-accent);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--space-sm);
  }

  .feature-modal-body .detail-columns {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-md);
    margin-bottom: var(--space-md);
  }

  .feature-modal-body .detail-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--space-md);
    margin: var(--space-lg) 0;
  }

  .detail-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: var(--space-md);
    background: var(--color-bg-primary);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    text-align: center;
  }

  .detail-stat-value {
    font-family: var(--font-display);
    font-size: 1.5rem;
    font-weight: 500;
    color: var(--color-accent);
    letter-spacing: -0.02em;
  }

  .detail-stat-label {
    font-size: 0.75rem;
    color: var(--color-text-secondary);
    margin-top: 0.25em;
  }

  .feature-modal-footer {
    margin-top: var(--space-xl);
    padding-top: var(--space-md);
    border-top: 1px solid var(--color-border);
  }

  .feature-modal-link {
    font-family: var(--font-mono);
    font-size: 0.8125rem;
    font-weight: 500;
    color: var(--color-accent);
    text-decoration: none;
    transition: opacity 0.2s ease;
  }

  .feature-modal-link:hover {
    opacity: 0.8;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @media (max-width: 1024px) {
    .features-grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .feature-modal-body .detail-columns {
      grid-template-columns: 1fr;
    }

    .feature-modal-body .detail-stats {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  @media (max-width: 640px) {
    .features {
      padding: var(--space-3xl) var(--space-md);
    }

    .features-grid {
      grid-template-columns: 1fr;
    }

    .feature-modal {
      padding: var(--space-lg);
      max-height: 90vh;
    }

    .feature-expand-hint {
      opacity: 1;
      transform: translateX(0);
    }
  }
</style>
