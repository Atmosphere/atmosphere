var atmosphere=(function(exports){'use strict';var d=class{constructor(t="warn"){this.level=t;}setLevel(t){this.level=t;}debug(t,...e){this.shouldLog("debug")&&console.debug(`[Atmosphere] ${t}`,...e);}info(t,...e){this.shouldLog("info")&&console.info(`[Atmosphere] ${t}`,...e);}warn(t,...e){this.shouldLog("warn")&&console.warn(`[Atmosphere] ${t}`,...e);}error(t,...e){this.shouldLog("error")&&console.error(`[Atmosphere] ${t}`,...e);}shouldLog(t){let e=["debug","info","warn","error","silent"],s=e.indexOf(this.level);return e.indexOf(t)>=s}},o=new d;var c=class{constructor(t,e){this._state="disconnected";this.request=t,this.handlers=e;}get state(){return this._state}notifyOpen(t){this._state="connected",o.debug(`${this.name} transport opened`),this.handlers.open?.(t);}notifyMessage(t){o.debug(`${this.name} message received`),this.handlers.message?.(t);}notifyClose(t){this._state="closed",o.debug(`${this.name} transport closed`),this.handlers.close?.(t);}notifyError(t){this._state="error",o.error(`${this.name} transport error:`,t),this.handlers.error?.(t);}notifyReconnect(t,e){this._state="reconnecting",o.info(`${this.name} reconnecting...`),this.handlers.reconnect?.(t,e);}buildUrl(t){try{let e=new URL(t,window.location.href);return this.request.headers&&Object.entries(this.request.headers).forEach(([s,r])=>{e.searchParams.set(s,r);}),e.toString()}catch(e){return o.error("Failed to build URL:",e),t}}};var p=class extends c{constructor(){super(...arguments);this.ws=null;this.reconnectAttempts=0;this.reconnectTimer=null;}get name(){return "websocket"}async connect(){return new Promise((e,s)=>{try{this._state="connecting";let r=this.buildWebSocketUrl(this.request.url);o.debug(`Connecting to WebSocket: ${r}`),this.ws=new WebSocket(r),this.ws.binaryType="arraybuffer",this.ws.onopen=n=>{this.handleOpen(n),e();},this.ws.onmessage=n=>{this.handleMessage(n);},this.ws.onerror=()=>{let n=new Error("WebSocket connection error");this.handleError(n),s(n);},this.ws.onclose=n=>{this.handleClose(n);};}catch(r){this.handleError(r),s(r);}})}async disconnect(){this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.ws?.readyState===WebSocket.OPEN&&this.ws.close(),this.ws=null,this._state="disconnected";}send(e){if(!this.ws||this.ws.readyState!==WebSocket.OPEN)throw new Error("WebSocket is not connected");this.ws.send(e);}buildWebSocketUrl(e){let s=new URL(this.buildUrl(e),window.location.href);return s.protocol=s.protocol.replace("http","ws"),s.toString()}handleOpen(e){this.reconnectAttempts=0,o.info("WebSocket connection established");let s={status:200,reasonPhrase:"OK",responseBody:"",messages:[],headers:{},state:"open",transport:"websocket",error:null,request:this.request};this.notifyOpen(s);}handleMessage(e){(this.request.trackMessageLength?this.splitMessages(e.data):[e.data]).forEach(r=>{if(r){let n={status:200,reasonPhrase:"OK",responseBody:r,messages:[r],headers:{},state:"messageReceived",transport:"websocket",error:null,request:this.request};this.notifyMessage(n);}});}handleClose(e){if(this.request.closed)return;o.info(`WebSocket closed: code=${e.code}, reason=${e.reason}`);let s={status:e.code,reasonPhrase:e.reason||"Connection closed",responseBody:"",messages:[],headers:{},state:"closed",transport:"websocket",error:null,request:this.request};this.notifyClose(s),this.request.reconnect&&this.reconnectAttempts<(this.request.maxReconnectOnClose??5)&&this.scheduleReconnect();}handleError(e){o.error("WebSocket error:",e),this.notifyError(e);}scheduleReconnect(){let e=this.calculateReconnectDelay();this.reconnectAttempts++,o.info(`Scheduling reconnection attempt ${this.reconnectAttempts} in ${e}ms`),this.reconnectTimer=window.setTimeout(()=>{this.connect().catch(s=>{o.error("Reconnection failed:",s);});},e);}calculateReconnectDelay(){let s=(this.request.reconnectInterval??1e3)*Math.pow(2,Math.min(this.reconnectAttempts,5)),r=.5+Math.random()*.5;return s*r}splitMessages(e){let s=this.request.messageDelimiter??`
`;return e.split(s).filter(r=>r.length>0)}};var l=class{constructor(t={}){this.version="5.0.0-alpha.1";this.subscriptions=new Map;this.subscriptionId=0;this.config=t,t.logLevel&&o.setLevel(t.logLevel);}async subscribe(t,e={}){let s=`sub-${++this.subscriptionId}`;o.info(`Creating subscription ${s} to ${t.url}`);let r=this.createTransport(t,e);await r.connect();let n=new Map,u={id:s,get state(){return r.state},push:i=>{let a=typeof i=="string"||i instanceof ArrayBuffer?i:JSON.stringify(i);r.send(a);},close:async()=>{await r.disconnect(),this.subscriptions.delete(s),o.info(`Subscription ${s} closed`);},on:(i,a)=>{n.has(i)||n.set(i,new Set),n.get(i).add(a);},off:(i,a)=>{let m=n.get(i);m&&m.delete(a);}};return this.subscriptions.set(s,u),u}async closeAll(){o.info("Closing all subscriptions");let t=Array.from(this.subscriptions.values()).map(e=>e.close());await Promise.all(t);}getSubscriptions(){return Array.from(this.subscriptions.values())}createTransport(t,e){let s=t.transport||this.config.defaultTransport||"websocket";if(s==="websocket")return new p(t,e);throw new Error(`Unsupported transport: ${s}`)}};var R=new l,L="5.0.0-alpha.1";exports.Atmosphere=l;exports.BaseTransport=c;exports.VERSION=L;exports.WebSocketTransport=p;exports.atmosphere=R;exports.logger=o;return exports;})({});//# sourceMappingURL=index.global.js.map
//# sourceMappingURL=index.global.js.map